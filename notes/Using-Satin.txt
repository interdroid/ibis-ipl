Satin is a parallel programming environment for divide-and-conquer
parallelization, and (as a special case) worker-farmer parallelization.

To use Satin, the programmer must label one or more methods in the program
as Satin tasks. This is done by defining an interface that extends
ibis.satin.Spawnable. All methods that implement a method in such an
interface are Satin tasks. For example, given the following interface:

interface Searcher extends ibis.satin.Spawnable
{
    public int search( int a[], int from, int to, int val );
}

all methods that implement Searcher.search() will be Satin tasks.
In general such a marker interface may contain an arbitrary number
of methods. A Satin task method may have an arbitrary signature:
there are no restrictions on the type or number of parameters.

A class that implements such an interface must extend
ibis.satin.SatinObject, and must implement java.io.Serializable.

The result of a task method can only be used after the invocation of
ibis.satin.SatinObject.sync(). (Remember that a class that implements
a task method must extend SatinObject.) 

Thus we could provide the following implementation of the
search method shown above:

class Search1 extends ibis.satin.SatinObject implements java.io.Serializable {
    public int search( int a[], int from, int to, int val )
    {
        for( int i=from; i<to; i++ ){
            if( a[i] == val ) return i;
        }
        return -1;
    }
}

Now, this method can be invoked as follows:

    Search1 s = new Search1();
    int a[] = new int[200];

    // Do searches on two sub-domains of the array.
    int res1 = s.search( a, 0, 100, 0 );
    int res2 = s.search( a, 100, 200, 0 );

    // Wait for the results of the two invocations above.
    s.sync();

    // Now compute an overall result.
    int res = (res1>0)?res1:res2;

As part of the Satin `contract', Satin is free to execute the two
invocations to search() in parallel. In general, an arbitrary number of
invocation to Satin task methods may be done.

It is also allowed to invoke task methods from task methods, for example:


class Search2 extends ibis.satin.SatinObject implements java.io.Serializable {
    public int search( int a[], int from, int to, int val )
    {
        if( from==to ){
            return -1;
        }
        if( from+1==to ){
            return (a[from] == val)?from:-1);
        }
        int mid = (from+to)/2;
        int res1 = search( a, from, mid, val );
        int res2 = search( a, mid, to, val );
        sync();
        return (res1>0)?res1:res2;
    }
}

TODO: Exceptions, killing of task trees, spawning lots of methods
is a good idea.

-satin-closed

    Only use the initial set of hosts for the computation; do not allow
    further hosts to join the computation later on.


-satin-stats

    Show some statistics on the ibis run.
