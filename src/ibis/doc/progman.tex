\documentclass[10pt]{article}

\usepackage{html}

\newcommand{\mysection}[1]{\section{#1}\label{#1}}
\newcommand{\mysubsection}[1]{\subsection{#1}\label{#1}}
\newcommand{\mysubsubsection}[1]{\subsubsection{#1}\label{#1}}

\begin{document}

\title{
{\html {\htmladdnormallink{Ibis} {http://www.cs.vu.nl/ibis/}}}
{\latex {Ibis}}
Programmer's Manual}

\author{The Ibis Group}

\maketitle

\section{Introduction}

This manual describes how to write and run Ibis applications.
\begin{htmlonly}
It is also available in
\htmladdnormallink{postscript}{http://www.cs.vu.nl/ibis/progman.ps.gz}.
\end{htmlonly}
Ibis is a Java-centric grid programming environment.
It is described in several publications (see Section \ref{Further Reading}).
Rather than giving a detailed overview of what each class and method does,
the aim of this document is to describe how to actually use these classes
and methods.
The \emph{docs/api} subdirectory of the Ibis installation provides
documentation for each class and method.
\begin{htmlonly}
The Ibis API is also available
\htmladdnormallink{here}{http://www.cs.vu.nl/ibis/api/index.html}.
\end{htmlonly}
Fragments of an actual Ibis application will be used for illustration purposes.
Section \ref{An Ibis Application} will discuss a typical Ibis application,
with subsections on each phase of the program.
Section \ref{Compiling and Running an Ibis Application} will discuss how to
actually compile and run this program.

We also built several systems on top of Ibis.
Section \ref{The Satin Divide-and-Conquer System}
gives an overview of the Satin divide-and-conquer
system, and Section \ref{The GMI System} discusses GMI
(Group Method Invocation),
a flexible group communication system.
We also built a (not quite complete) RMI (Remote Method Invocation)
implementation on top of Ibis. RMI documentation can be found on-line at
{\html {\htmladdnormallink{http://java.sun.com}{http://java.sun.com}}}
{\latex {http://java.sun.com}}.
Section \ref{Ibis RMI} briefly discusses the Ibis RMI implementation.

\mysection{Some Ibis concepts}

\mysubsection{The Ibis Portability Layer}

The top layer of the Ibis system consists of the Ibis Portability Layer(IPL).
The IPL consists of a set of Java interfaces that define how an Ibis application
can make use of the Ibis components.
The Ibis application does not need to know which specific Ibis implementations are
available.
It just specifies some properties that it requires, and the Ibis system
selects the best available Ibis implementation that meets these requirements.
 
\mysubsection{An Ibis Instance}

A loaded Ibis implementation is called an \emph{Ibis instantiation}, or 
\emph{Ibis instance}.
An Ibis instance is identified by a so-called
\emph{Ibis identifier}.
An application can find out which Ibis instances are present in the run
by supplying a so-called \emph{ResizeHandler}.
This ResizeHandler is an object with, among others, a \emph{join} method
which gets called by the Ibis system when a new Ibis instance joins the
run.
The Ibis identifier of this new Ibis is a parameter to the join method.

\mysubsection{Send Ports and Receive Ports}

The IPL provides communication primitives using send ports and receive ports.
The Ibis application creates the send ports and receive ports, and sets up
connections between them, using primitives provided by the IPL.
A connection is \emph{unidirectional}, from a send port to one or more
receive ports.
To send a message, the Ibis application has to obtain a
write message from a send port, put data in this write message using
the methods provided by the write message, and \emph{finish} the
message.
To receive a message, the IPL provides two mechanisms:
\begin{description}
\item[explicit receipt]
when a receive port is configured for explicit receipt, a message can be
received with the receive port's blocking \emph{receive} primitive.
This method returns a \emph{read message} object. from which data can
be extracted using its read methods.
\item[upcalls]
when a receive port is configured for upcalls, the Ibis application provides
an \emph{upcall} method, which is to be called when a message arrives.
The upcall provides the message received as a parameter.
The message contents will be lost when the upcall returns, so the data
in the message must be read in the upcall.
\end{description}

\mysubsection{Port Types}

Send and receive ports are \emph{typed} by means of a \emph{port type}.
A port type is defined and configured with properties.
Only ports of the same type can be connected.
Port type properties that can be configured are, for instance, the
serialization method used, reliability, whether a send port can connect
to more than one receive port, whether more than one send port can connect
to a single receive port, et cetera.

\mysubsection{Serialization}

Serialization is a mechanism for converting Java objects into some
format that can be stored or transferred.
Java has input (java.io.ObjectInputStream) and output
(java.io.ObjectOutputStream) streams for reading and writing objects.
In Ibis, we call this mechanism \emph{Sun serialization}.
Ibis also has its own mechanism, which is completely compatible
(with regard to its interface) with Sun serialization, but more efficient.
We call this mechanism \emph{Ibis serialization}.

Sometimes, object serialization is not needed. For that case, two simpler
serialization mechanisms are available: \emph{data serialization} which
allows for sending/receiving data of basic types and arrays of basic types
(similar to java.io.DataInputStream/java.io.DataOutputStream), and
\emph{byte serialization} which only allows sending/receiving bytes
and arrays of bytes.

\mysection{An Ibis Application}

An Ibis application consists of several parts:
\begin{itemize}
\item
Creating an Ibis in each instance of the application.
An Ibis application runs on multiple hosts. On each of these hosts, an Ibis
must be created.
\item
Setting up communication. A communication connection consists of a
\emph{send port}, through which messages can be sent, and one or
more \emph{receive ports},
through which messages can be received, and a connection between them.
\item
Actually communicating. A send port is used to create a 
\emph{write message}, which is sent to the receive ports that this send port
is connected to.
\item
Finishing up. Connections must be closed, and each Ibis instance must
be ended.
\end{itemize}

The next few subsections will discuss each of these steps in turn,
illustrating them with parts of an RPC-style Ibis application.
This application will have a client and a server. As this is a toy
application, the server will have to compute the length of a string.
The client will send the string, and receive the result.
The server will have to do some other work as well, just to make
things a little more interesting.

\subsection{Program Preamble}

All Ibis applications import classes from the IPL (Ibis
Portability Layer) package, which lives in
\verb+ibis.ipl+.
So, the preamble of your program could just consist of one line:
\begin{quote}
\begin{verbatim}
import ibis.ipl.*;
\end{verbatim}
\end{quote}
It might also exist of an import of each class that is used,
but this might easily result in a list of 10 or more \verb+import+s.

\mysubsection{Creating an Ibis Instance}

All instances of a program that want to participate in an Ibis run
must create an Ibis instance.
To create an Ibis instance, the \verb+createIbis+ method of the
\verb+ibis.ipl.Ibis+ class must be used.
The specification of this method is:
\begin{quote}
\begin{verbatim}
Ibis createIbis(StaticProperties props,
                ResizeHandler h)
        throws IbisException;
\end{verbatim}
\end{quote}
There may be several Ibis implementations available, and
the system selects the best one for you, based on some
user-specified requirements.
These requirements tell the system what features must be supported
by the selected Ibis.
They are summarized in an object of the
\verb+ibis.ipl.StaticProperties+ class.
For example, below is a snippet from the RPC example:
\begin{quote}
\begin{verbatim}
StaticProperties props = new StaticProperties();
props.add("communication", "OneToOne, Reliable, " + 
                           "AutoUpcalls, ExplicitReceipt");
props.add("serialization", "object");
props.add("worldmodel", "closed");
\end{verbatim}
\end{quote}
This states that the selected Ibis must support reliable one-to-one
communication, must support upcalls at the receiver side without the
receiver having to poll for messages, and must also support explicit
receipt of messages at the receiver side.
(We want upcalls so that the server can do other work, and we want
explicit receipt for the client side).
In addition, the selected Ibis must support some form of object
serialization (a string must be sent),
and must support the ``closed'' worldmodel, which means
that all participating Ibises join at the start of the run, and a
synchronization takes place before \verb+createIbis+ returns.
(in the example we have a client and a server).

A complete list of property values is given below.
The possible property values of the ``communication'' property are
(capitals are not significant):
\begin{description}
\item[OneToOne]
One-to-one (unicast) communication is supported (if an Ibis does not support
this, you may wonder what it \emph{does} support).
\item[OneToMany]
one-to-many (multicast) communication is supported.
(in Ibis terms: a sendport
may connect to multiple receiveports).
\item[ManyToOne]
many-to-one communication is supported (in Ibis terms: multiple
sendports may connect to a single receiveport).
\item[FifoOrdered]
messages from a send port are delivered to the receive ports it is
connected to in the order in which they were sent.
\item[Sequenced]
all messages originating from any send port of a specific port type have
a sequence number. This allows the application to do its own sequencing.
\item[Reliable]
reliable communication is supported, that is,
a reliable communication protocol is used.
When not specified, an Ibis may be chosen that does not explicitly
support reliable communication.
\item[AutoUpcalls]
upcalls are supported and polling for them is not required.
This means that when the user creates a receiveport with an upcall
handler installed, when a message arrives at that receive port, 
this upcall handler is invoked automatically.
\item[PollUpcalls]
upcalls are supported but polling for them is required. When an
Ibis implementation claims that it has this, it may also do
AutoUpcalls but polling does no harm. When an application asks for
this (and not AutoUpcalls), it must poll.
\item[ExplicitReceipt]
explicit receive is supported.
This is the alternative way to upcalls for receiving messages.
\item[ConnectionDowncalls]
connection downcalls are supported. This means that the user can
invoke methods to see which connections were lost or created.
\item[ConnectionUpcalls]
connection upcalls are supported. This means that an upcall
handler can be installed that is invoked whenever a new connection arrives
or a connection is lost.
\end{description}

The possible ``serialization'' properties are:
\begin{description}
\item[Byte]
readByte/writeByte and readArray/writeArray(byte[]) are supported.
\item[Data]
read/write and readArray/writeArray of basic types are supported.
\item[Object]
Some sort of object serialization is supported. An Ibis implementation
will, of course, specify what kind of object serialization it supports.
The ``Object'' property allows a user to just ask for object
serialization, and not care if it is Ibis or Sun serialization.
\item[Ibis]
Ibis serialization is supported.
This is the fastest object serialization supported in Ibis. Its drawback
is that it requires identical Java implementations on sender and
receiver side, and does not support
non-symmetrical writeObject/readObject methods (where readObject does not
read everything that writeObject writes).
\item[Sun]
Sun serialization (through java.io.ObjectOutputStream/InputStream) is
supported.
\end{description}

The possible ``worldmodel'' properties are:
\begin{description}
\item[Open]
this means that Ibises can join the run at any time during the run.
\item[Closed]
this means that the Ibises that can join the run are determined
at the start of the run.
\end{description}

If a specific implementation of Ibis is required, that can be dealt with too.
There is a property called ``name'', which can be used to supply a nickname
for the Ibis implementation that is required.
The currently known nicknames are:
\begin{description}
\item[tcp]
This is an Ibis implementation on top of TCP sockets, and currently is
probably the most stable Ibis around, and it supports almost all properties.
\item[panda]
This is a messagePassing Ibis implementation on top of the Panda
communication layer. It only supports the ``closed'' worldmodel,
but on our system it gives much higher throughput and lower latencies
because it runs on Myrinet instead of our (100Mbitps) Ethernet on which
the TCP version runs.
\item[net]
This is the most flexible Ibis implementation, but still in an experimental
stage.
\item[nio]
This is a (still experimental) Ibis implementation on top of Java NIO.
\item[mpi]
This is the messagePassing Ibis implementation but on top of MPI instead
of Panda. This too is an experimental version.
\end{description}

A user running an Ibis application can override a property, or make it
more specific. This is done by means of Java system properties, which
in many Java implementations can be set by means of a command line option,
for instance -D\emph{property}=\emph{value}.
The system property name is that of the Ibis static property, prefixed
with ``\verb+ibis.+''.
So, adding \verb+-Dibis.serialization=ibis+ to the command line will
cause \verb+createIbis+ to look for an Ibis that supports ibis serialization
instead of any object serialization.

This completes the description of the first parameter
of \verb+createIbis+. The second parameter specifies an upcall handler
with \verb+join+ and \verb+leave+ upcalls that get called when an Ibis
joins or leaves the run.
In our RPC example, we will not use this, so we specify \verb+null+
instead.
However, when such a \verb+ResizeHandler+ is used, its \verb+join+
upcall is called for every Ibis that joins the run, including the
Ibis being created.
To prevent upcalls from occurring before the
creation of this Ibis is completed, these upcalls must be explicitly
enabled by invoking the \verb+openWorld+ method of the Ibis just
created. In addition, the \verb+openWorld+ method blocks until the
\verb+join+ upcall for this Ibis has been invoked.
Knowing which Ibises have joined the run, and how many there are, may
be useful in dividing the work. See also section \ref{Which Instance Does What?}.

Now back to our example. 
With the \verb+props+ as defined above, we create an Ibis as follows:
\begin{quote}
\begin{verbatim}
try {
    Ibis ibis = createIbis(props, null);
} catch(NoMatchingIbisException e) {
    System.err.println("Could not find a matching Ibis");
    ...
}
\end{verbatim}
\end{quote}
Note that the properties can be so specific that no matching Ibis
can be found. Therefore, \verb+createIbis+ may throw an exception
indicating this.

\subsection{Setting up Communication}

Setting up communication consists of several steps:
\begin{itemize}
\item
create a port type;
\item
create a send and a receive port;
\item
setting up connections between them.
\end{itemize}

The next few subsections discuss each of these steps in turn.

\subsubsection{Creating a Port Type}

The next step is to create a \emph{port type}, from which
send and receive ports can be created. A port type is an object
of type \verb+ibis.ipl.PortType+.
Within an Ibis instance,
multiple port types, with different properties, can be created.
The properties of a port type are, like the required properties
of an Ibis, specified by a \verb+StaticProperties+ object.
A port type is identified by its name, together with these properties.
The \verb+Ibis+ class contains a method to create a port type,
specified as follows:
\begin{quote}
\begin{verbatim}
PortType createPortType(String name,
                        StaticProperties portprops)
        throws IbisException, java.io.IOException;
\end{verbatim}
\end{quote}

For our RPC example program, we would create a port type with properties
as discussed in Section \ref{Creating an Ibis Instance}:

\begin{quote}
\begin{verbatim}
StaticProperties portprops = new StaticProperties();
portprops.add("communication",
              "OneToOne, Reliable, " + 
                  "AutoUpcalls, ExplicitReceipt");
portprops.add("serialization", "object");
PortType porttype = null;
try {
    porttype = ibis.createPortType("RPC port", portprops);
} catch(Exception e) {
    ...
}
\end{verbatim}
\end{quote}

In general, the port properties should be a subset of the properties
specified when creating the Ibis instance. If a property is specified
that was not specified when creating the Ibis instance, this could
result in an \verb+IbisException+.
An \verb+IbisException+ could also result when the same name is
already used for a port type with different properties.
Port types are registered with an internal or external name server
(this will be discussed in Section \ref{Compiling and Running an Ibis Application}).
If communication with this name server fails, a
\verb+java.io.IOException+ is thrown.

\mysubsubsection{Which Instance Does What?}

Up until now, we have discussed only matters that all instances of
the Ibis application should do, but now, things become different.
One instance of the application may want to send messages, while
another instance may want to receive them.
It may not even be clear which instance is going to do what.
This can of course be solved with program parameters, but Ibis
also provides a so-called registry (of type
\verb+ibis.ipl.Registry+), which is obtained through the
\verb+ibis.registry+ method.
Ibis also provides the \verb+ibis.ipl.IbisIdentifier+ class.
the \verb+ibis.ipl.Ibis.identifier+ method returns such an
Ibis identifier, which identifies this specific Ibis instance.
Now it is possible to decide, in the RPC example, who is going
to be the server by means of an ``election'': the Ibis registry
provides a method \verb+elect+ which (globally) selects one of
a number of invokers.
For our RPC example this would go as follows:

\begin{quote}
\begin{verbatim}
IbisIdentifier me = ibis.identifier();
Registry registry = ibis.registry();
IbisIdentifier server = (IbisIdentifier)
                          registry.elect("Server", me);
boolean i_am_server = server.equals(me);
\end{verbatim}
\end{quote}

It could also be that the client and the server are separate programs.

The \verb+ResizeHandler+, as discussed in Section
\ref{Creating an Ibis Instance}, can be used to keep track of the number
of Ibis instances currently involved in the run.

\subsubsection{Creating Send and Receive Ports}

The \verb+PortType+ class contains several variants of a method
\verb+createSendPort+ that creates a send port (of type
\verb+ibis.ipl.SendPort+) and
also several variants of a method \verb+createReceivePort+ that
creates a receive port (of type \verb+ibis.ipl.ReceivePort+),
See the API for an exhaustive list of variants.

In Ibis, receive ports usually have specific names, so that
a send port can set up a connection to a receive port. In contrast,
send ports usually are anonymous, because a receive port cannot
initiate a connection.

For our RPC example, the server will have to create a receive port
to receive a request and a send port to send an answer.
The server is not allowed to block waiting for a request, so it will
want a receive port that enables upcalls.
To do that, the server must first define a class that implements
the \verb+ibis.ipl.Upcall+ interface. This interface contains one
method:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws java.io.IOException;
\end{verbatim}
\end{quote}

We will go into the details of a \verb+ReadMessage+ in Section
\ref{Communicating}. For now, we will assume that there is a
class \verb+RPC_Upcall+ that implements this interface, and
a field \verb+rpc_upcall+ of this type.

\begin{quote}
\begin{verbatim}
try {
    SendPort server_sender = porttype.createSendPort();
    ReceivePort server_receiver =
        porttype.createReceivePort("server", rpc_upcall);
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

The client will have to create a send port
to send a request and a receive port to receive an answer.
The client is allowed to block waiting for an answer, so it will
want a receive port that enables explicit receipt.
So, the client will create an anonymous server port, and a named
receive port that enables explicit receipt:

\begin{quote}
\begin{verbatim}
try {
    SendPort client_sender = porttype.createSendPort();
    ReceivePort client_receiver =
        porttype.createReceivePort("client");
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

When a receive port is created, it will not immediately accept connections.
This must be explicitly enabled by
invoking the \verb+enableConnections+ method. So, the creator of
the receive port can determine when he is ready to accept connections.
If the receive port is configured for upcalls, these must
explicitly be enabled by invoking the \verb+enableUpcalls+ method.

\subsubsection{Setting Up a Connection}

Now that we have send ports and receive ports, it is time to set up
connections between them.
A connection is initiated by the \verb+connect+ method of
\verb+ibis.ipl.SendPort+.
Here is its specification:

\begin{quote}
\begin{verbatim}
void connect (ReceivePortIdentifier r) throws IOException;
\end{verbatim}
\end{quote}

This version blocks until an accept or deny is received, and throws
an \verb+IOException+ when the connection could not be established.
There also is a \verb+connect+ version with a time-out.

So, we need a \verb+ibis.ipl.ReceivePortIdentifier+ to set up the
connection.
This identifier can be obtained through the Ibis registry, by
means of the \verb+lookup+ method, which has the following specification:

\begin{quote}
\begin{verbatim}
ReceivePortIdentifier lookup(String name)
        throws IOException;
\end{verbatim}
\end{quote}

This method blocks until a receive port with the specified name is found.
Our RPC server would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier client = registry.lookup("client");
    server_sender.connect(client);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

Our RPC client would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier srvr = registry.lookup("server");
    client_sender.connect(srvr);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

This completes the connection setup.

Note that a send port can set up connections to more than one
receive port (if the port type supports the \verb+OneToMany+
communication property). Also, multiple send ports can set up
connections to the same receive port (if the port type supports
the \verb+ManyToOne+ communication property).

\mysubsection{Connection upcalls, connection downcalls}

Sometimes it is useful for an application to know which send ports
are connected to a receive port, and vice versa, or which connections
are being closed.
Ibis implementations may support two different mechanisms for obtaining
this type of information: connection upcalls and connection downcalls.

When a port type is configured for using connection upcalls,
a receive port may be instantiated with a \verb+ReceivePortConnectUpcall+
object. This is an interface with two methods:

\begin{quote}
\begin{verbatim}
boolean gotConnection(ReceivePort me,
                      SendPortIdentifier applicant);
void lostConnection(ReceivePort me,
                    SendPortIdentifier johndoe,
                    Exception reason);
\end{verbatim}
\end{quote}

The \verb+gotConnection+ method gets called when a send port attempts
to connect to the receive port at hand.
An implementation of this method can decide whether
to allow this connection or not.
The \verb+lostConnection+ method gets called when an existing connection
to the receive port at hand gets lost for some reason.

A send port can be instantiated with a
\verb+SendPortConnectUpcall+ object. This is an interface with a single method:

\begin{quote}
\begin{verbatim}
void lostConnection(SendPort me,
                    ReceivePortIdentifier johndoe,
                    Exception reason);
\end{verbatim}
\end{quote}

This method gets called when an existing connection from the send port at
hand gets lost for some reason. Note that there is no \verb+gotConnection+
counterpart, because it is always the send port that initiates a connection.

When port type is configured for using connection downcalls, receive ports
and send ports of this type maintain connection information.
A receive port has the following methods:

\begin{quote}
\begin{verbatim}
SendPortIdentifier[] newConnections();
SendPortIdentifier[] lostConnections();
SendPortIdentifier[] connectedTo();
\end{verbatim}
\end{quote}

\verb+newConnections+ returns the send port identifiers of the connections
that are new since the last call or the start of the program.
\verb+lostConnections+ returns the send port identifiers of the connections
that were lost since the last call or the start of the program.
\verb+connectedTo+ returns the send port identifiers of all connections
to this receive port.

A send port has the following methods:

\begin{quote}
\begin{verbatim}
ReceivePortIdentifier[] newConnections();
ReceivePortIdentifier[] lostConnections();
ReceivePortIdentifier[] connectedTo();
\end{verbatim}
\end{quote}

\verb+newConnections+ returns the receive port identifiers of the connections
that are new since the last call or the start of the program.
\verb+lostConnections+ returns the receive port identifiers of the connections
that were lost since the last call or the start of the program.
\verb+connectedTo+ returns the receive port identifiers of all connections
from this send port.

\mysubsection{Communicating}

As the reader may have noticed by now, communication in Ibis
consists of messages, sent from a send port, and received at a
receive port. When a sender wants to send a message, it will first
have to obtain one from the send port. Such a message is of
type \verb+ibis.ipl.WriteMessage+ and is obtained by means of
the \verb+newMessage+ method of \verb+SendPort+, which is specified
as follows:

\begin{quote}
\begin{verbatim}
WriteMessage newMessage() throws IOException;
\end{verbatim}
\end{quote}

For a given send port, only one message can be alive at any time.
When a new message is requested while a message is alive, the request
is blocked until the live message is finished.

Once a write message is obtained, data can be written to it.
A write message has various methods for the different types of
data that can be written to it. For instance, the
\verb+writeInt+ method can be used to write an integer value,
and the \verb+writeObject+ method can be used to write an object.
The kind of data that can be written to the message depends on the
serialization property specified when the port type was created.
The most general form is object serialization, which supports 
all write methods in a write message.
The \verb+data+ serialization property does not allow use of the
\verb+writeObject+ method, but does allow the use of all other write
methods. The \verb+byte+ serialization property only allows use
of the \verb+writeByte+ method and the \verb+writeArray(byte[])+
method.

Once there is a considerable amount of data in the message, Ibis
can be given a hint to start sending, using the \verb+send()+
method. This hint is not needed, however. When the message is
complete, the message can be sent out by invoking the
\verb+finish()+ method.

Our client in the RPC example could have the following:
\begin{quote}
\begin{verbatim}
int obtainLength(String s) throws IOException {
    WriteMessage w = client_sender.newMessage();
    w.writeObject(s);
    w.finish();
    ...
\end{verbatim}
\end{quote}

At the receiving side, a message can be received in two ways,
depending on how the receive port was created: either by means of an
upcall, or by means of an explicit receive. For each write method
in a write message, there is a corresponding read method in
a read message. For a given receive port, only one message can
be alive at any time. A read message is alive until it is
finished (by a \verb+finish+ call), or the upcall returns.

Now, let us present some more code of our RPC example, this time
from the server:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws IOException {
    String s = (String) m.readObject();
    int len = s.length;
    m.finish();
    WriteMessage w = server_sender.newMessage();
    w.writeInt(len);
    w.finish();
}
\end{verbatim}
\end{quote}

Note that the read message is finished before replying to the
request. To prevent deadlocks, upcalls are not allowed to block in
condition synchronization or network access as long as the message
is active. This means that a thread is not allowed to write as long
as a read message is active, and a thread is not allowed to wait for
some condition (call \verb+Thread.wait()+).

Now, we can also finish the \verb+obtainLength+ method of the client:
\begin{quote}
\begin{verbatim}
    ...
    ReadMessage r = client_receiver.receive();
    int len = r.readInt();
    r.finish();
    return len;
}
\end{verbatim}
\end{quote}

\subsection{Finishing up}

Closing of a connection is initiated by closing a send port
(by means of the \verb+close+) method. The \verb+ReceivePort+
class also has a \verb+close+ method, but this method blocks
until all send ports that have a connection to it are closed.
So, send ports have to be closed first.

Our RPC client will do the following:

\begin{quote}
\begin{verbatim}
client_sender.close();
client_receiver.close();
\end{verbatim}
\end{quote}
and the code of the server should be clear by now.

Ibis itself must also be ended. Both our client and our server
should invoke the \verb+Ibis.end+ method:
\begin{quote}
\begin{verbatim}
ibis.end();
\end{verbatim}
\end{quote}

As of Java 1.3, it is also possible to add a so-called shutdown hook.
This could be done right after the Ibis instance is created:
\begin{quote}
\begin{verbatim}
Runtime.getRuntime().addShutdownHook(new Thread() {
    public void run() {
        try {
            ibis.end();
        } catch (IOException e) {
        }
    }
});
\end{verbatim}
\end{quote}

This shutdown hook gets invoked when the program terminates.

\mysubsection{Ibis utilities}

The \verb+ibis.util+ package contains several utilities that may be
useful for Ibis applications. We will discuss some of them here.

\mysubsubsection{PoolInfo}

The \verb+ibis.util.PoolInfo+ class is a very useful utility for
closed-world applications.
It provides methods for finding out information about the nodes
involved in the closed-world run, such as:
\begin{itemize}
\item
the total number of hosts involved in the run.
\item
the rank number of the current host in the pool.
\item
the host names of the hosts involved in the run.
\item
the \verb+InetAddress+ of the hosts involved in the run.
\end{itemize}

The preferred way of creating a \verb+PoolInfo+ is by means of the
static method \verb+createPoolInfo+.
It depends on the following system properties:
\begin{description}
\item[ibis.pool.total\_hosts]
This system property must be present for closed-world runs.
It indicates the total number of hosts involved in the run.
\item[ibis.pool.host\_names]
If present, this system property contains the list of host names
involved in the run.
If not present, \verb+createPoolInfo+ will a \verb+PoolInfoClient+
that will collect this information during startup.
\item[ibis.pool.host\_number]
If present, this system property indicates the rank number of the
current host. If not present, the system will provide a rank number.
\end{description}

\mysubsubsection{PoolInfoClient}

The \verb+ibis.util.PoolInfoClient+ is a subclass of
\verb+ibis.util.PoolInfo+.
It uses a \verb+PoolInfoServer+ to collect the required information.
This \verb+PoolInfoServer+ usually is started by the Ibis nameserver
(see Section \ref{The Ibis Nameserver}.

\mysection{Compiling and Running an Ibis Application}

Before running an Ibis application it must be compiled.
Using \emph{ant}, this is quite easy. Here is a build.xml file for
our example program:

\begin{quote}
\begin{verbatim}
<project
    name="client-server"
    default="build"
    basedir=".">

    <description>
    Ibis application build.
    </description>

    <property name="ibis"   location="/usr/local/ibis"/>
    <property name="build"  location="build"/>

    <import file="${ibis}/apps/ibis/build-ibis-app.xml"/>
</project>
\end{verbatim}
\end{quote}
Note that the assumption here is that Ibis is installed in
\verb+/usr/local/ibis+.

Now, invoking \emph{ant} compiles the application, leaving the class files
in a directory called \verb+build+.

\mysubsection{The Ibis Nameserver}

Most Ibis implementations depend on a name server.
The name server ...TODO...

\mysection{The Satin Divide-and-Conquer System}

Satin is a parallel programming environment for divide-and-conquer
parallelization, and (as a special case) worker-farmer parallelization.
Satin extends Java with two simple Cilk-like primitives for
divide-and-conquer programming.  The Satin byte-code rewriter and
runtime system cooperate to implement these primitives efficiently on
Ibis, using work stealing to distribute the jobs.

\mysubsection{Satin jobs}

To use Satin, the programmer must label one or more methods in the program
as Satin jobs. This is done by defining an interface that extends
the Satin interface \verb+ibis.satin.Spawnable+.
All methods that implement a method in such an
interface are Satin jobs. For example, given the following interface:

\begin{quote}
\begin{verbatim}
interface Searcher extends ibis.satin.Spawnable
{
    public int search( int a[], int from, int to, int val );
}
\end{verbatim}
\end{quote}

all methods that implement \verb+Searcher.search()+ will be Satin jobs.
In general such a marker interface may contain an arbitrary number
of methods.
When actually using Satin, invoking a Satin job puts this Satin job
on a job queue instead of invoking it directly.
Later on, the job will be executed either locally, or it will be
``stolen'' and executed by another processor.

The result of a Satin job can only be used after the invocation
of the \verb+sync()+ method, which lives in \verb+ibis.satin.SatinObject+.
(Remember that a class that implements a job method must extend
\verb+ibis.satin.SatinObject+.) The \verb+sync()+
method is guaranteed to only terminate after the earlier job
invocations have terminated.

Satin imposes one restriction on the type of parameters and return type
of a Satin job: they must be serializable.
A class that implements such an interface must extend
\verb+ibis.satin.SatinObject+, and must itself be serializable
(implement \verb+java.io.Serializable+).
These two restrictions ensure that a Satin job can be stored and
moved from one processor to another (not while it is running, but before
it is started).

As an example, we could provide the following implementation of the
search method shown above:

\begin{quote}
\begin{verbatim}
class Search1 extends ibis.satin.SatinObject
              implements java.io.Serializable {
    public int search( int a[], int from, int to, int val )
    {
        for( int i=from; i<to; i++ ){
            if( a[i] == val ) return i;
        }
        return -1;
    }
}
\end{verbatim}
\end{quote}

Now, this method can be invoked as follows:

\begin{quote}
\begin{verbatim}
    Search1 s = new Search1();
    int a[] = new int[200];

    // Do searches on two sub-domains of the array.
    int res1 = s.search( a, 0, 100, 0 );
    int res2 = s.search( a, 100, 200, 0 );

    // Wait for results of the two invocations above.
    s.sync();

    // Now compute an overall result.
    int res = (res1>0)?res1:res2;
\end{verbatim}
\end{quote}

As part of the Satin `contract', Satin is free to execute the two
invocations to \verb+search()+ in parallel.
In general, an arbitrary number of
invocations to Satin job methods may be done.

It is also allowed to invoke job methods from job methods, for example:

\begin{quote}
\begin{verbatim}
class Search2 extends ibis.satin.SatinObject
              implements java.io.Serializable {
    public int search( int a[], int from, int to, int val )
    {
        if( from==to ){
            return -1;
        }
        if( from+1==to ){
            return (a[from] == val)?from:-1);
        }
        int mid = (from+to)/2;
        int res1 = search( a, from, mid, val );
        int res2 = search( a, mid, to, val );
        sync();
        return (res1>0)?res1:res2;
    }
}
\end{verbatim}
\end{quote}

\mysubsection{Exceptions and abort}

A Satin job may throw exceptions in the usual way. This can be
used to rapidly terminate a large set of jobs, for example because
a search result was found. In such cases it is often useful to
terminate other running jobs.  This can be done with the
\verb+abort()+ method.
Satin has its own exception type: \verb+ibis.satin.Inlet+.
An \verb+Inlet+ is a \verb+Throwable+ that inhibits the generation of
a stack trace, which is an expensive operation.

For example:

\begin{quote}
\begin{verbatim}
class SearchResultException extends ibis.satin.Inlet {
    int pos;
    SearchResultException( int p ) { pos = p; }
}

class Search3 extends ibis.satin.SatinObject
              implements java.io.Serializable {
    public void search( int a[], int from, int to, int val )
    {
        if( from==to ){
            return;
        }
        if( from+1==to ){
            if( a[from] == val ){
                throw new SearchResultException( from );
            }
            return;
        }
        int mid = (from+to)/2;
        search( a, from, mid, val );
        search( a, mid, to, val );
        sync();
    }
}
\end{verbatim}
\end{quote}

Note that in this version the search method doesn't return a value,
since it will only terminate if no result is found.

At top level this exception must be caught, and the other search
jobs must be terminated. For example:

\begin{quote}
\begin{verbatim}
    Search3 s = new Search3();
    int a[] = new int[200];
    int res = -1;

    try {
        // Do searches on two sub-domains of the array.
        s.search( a, 0, 100, 0 );
        s.search( a, 100, 200, 0 );

        // Wait for results of the two invocations above.
        s.sync();
    }
    catch( SearchResultException x ){
        res = x.pos;
        s.abort();
    }
\end{verbatim}
\end{quote}

\mysubsection{Satin job scheduling}

Satin offers a choice of three different job scheduling strategies:
\begin{description}
\item[Random work-stealing]
when using random work-stealing, when looking for work, each Satin
first examines its own job queue. When this job queue is empty,
it selects another Satin and takes the first job on its job queue.
It that job queue is empty, it selects another Satin, et cetera, et cetera.
This strategy is the default.
\item[Cluster-aware random work-stealing]
this strategy is very similar to random work-stealing, except that
each participant first tries to steal jobs from other participants in its
own cluster (thus using a local network). It will only go to participants
from other clusters if no participant on the same cluster has work.
\item[Master-worker]
this strategy is suitable for applications where all Satin jobs are
generated on a single participant, the ``master''. All other participants
are ``workers'', they obtain jobs from the master and execute them.
\end{description}

Making sure that all participants always can find work to do may need
some tuning. Jobs must not be too small, because otherwise the mechanism
for obtaining jobs, which may involve network traffic, is too expensive.
On the other hand, there must be enough jobs to keep everybody busy.
The \verb+SatinObject+ class has a boolean method \verb+needMoreJobs()+,
which indicates whether it would be useful to generate more jobs.

\mysubsection{Other SatinObject methods}

The \verb+pause()+ method pauses Satin operation. When the application
contains a large sequential part, this method can be called to temporarily
pause Satin's internal load distribution strategies to avoid communication
overhead during the execution of sequential code.
To resume Satin operation, the \verb+resume()+ method must be used.

\mysubsection{Satin program arguments}

The Satin system accepts the following arguments, which are
filtered out from the program arguments, leaving the applications
arguments:
\begin{description}
\item[-satin-closed]
Only use the initial set of hosts for the computation; do not allow
further hosts to join the computation later on.
\item[-satin-stats]
Display some statistics at the end of the Satin run.
\item[-satin-detailed-stats]
Display detailed statistics for every member at the end of the Satin run.
\item[-satin-no-stats]
Don't display statistics at the end of the Satin run.
\item[-satin-panda]
Use the Panda version of Ibis.
\item[-satin-mpi]
Use the MPI version of Ibis.
\item[-satin-net]
Use NetIbis.
\item[-satin-nio]
Use NIO Ibis.
\item[-satin-tcp]
Use the TCP version of Ibis. This is the default.
\item[-satin-ibis]
Use Ibis serialization. When no serialization is specified,
the object serialization used is determined by Ibis.
\item[-satin-sun]
Use Sun serialization.
\item[-satin-upcalls]
Use upcalls for receiving messages. This is the default.
\item[-satin-no-upcalls]
Use explicit receipt for receiving messages.
\item[-satin-upcall-polling]
Use upcalls for receiving messages, but Satin must explicitly poll to get
upcalls.
\item[-satin-alg \emph{algorithm}]
Specify the load-balancing algorithm to use. The possible values for
\emph{algorithm} are: RS for random work-stealing, CRS for cluster-aware
random-work stealing, and MW for master-worker
\end{description}

The following flags are for tuning by the developers of Satin,
and should not be used unless you really know what you are doing.
\begin{description}
\item[-satin-queue-size \emph{integer}]
The maximum desirable job queue size. If the current work queue 
has more than this number of jobs, Satin indicates that 
it does not need more jobs (as can be asked though the
needMoreJobs() method).
\end{description}

\mysubsection{The Satin Tuple Space}

The \verb+ibis.satin.SatinTupleSpace+ class implements a global
tuple space.  A tuple consists of a key (a String) and its associated data
(a serializable object). Here, global means that the tuple space is
available on all members. The \verb+SatinTupleSpace+ has the following
static methods:

\begin{quote}
\begin{verbatim}
static void add(String key, Serializable data);
static Serializable get(String key);
static Serializable peek(String key);
static void remove(String key);
\end{verbatim}
\end{quote}

The \verb+add+ method adds a tuple to the tuple space, associating the
specified key with the specified data.
The \verb+get+ method obtains the data associated with the specified key.
It blocks until there is actually data associated with the key.
The \verb+peek+ method, in contrast, does not block, but returns
\verb+null+ instead.
The \verb+remove+ method removes the tuple that has the specified key.

All members can add tuples, and no global ordering is imposed on the
additions, unless the system property
\verb+satin.tuplespace.ordered+ is defined and represents the
boolean value \verb+true+. In this case, a global ordering is imposed.

The Satin tuple space supports \emph{active tuples}.
The \verb+ibis.satin.ActiveTuple+ interface serves
as a marker for active tuples. It contains a single method:

\begin{quote}
\begin{verbatim}
void handleTuple(String key);
\end{verbatim}
\end{quote}

When an active tuple is added (as data) to the tuple space,
its \verb+handleTuple+ method will be invoked on all members.
This can be used, for instance, for modifications of data that
is replicated on all members.

A serious limitation of the current tuple space is that it is
currently only supported for closed-world runs.

\mysubsection{Compiling and running a Satin program}

Before running a Satin application it must be compiled.
Using \emph{ant}, this is quite easy. Here is a build.xml file for
our example program:

\begin{quote}
\begin{verbatim}
<project
    name="Search"
    default="build"
    basedir=".">

    <description>
    Satin application build.
    </description>

    <property name="ibis"   location="/usr/local/ibis"/>
    <property name="build"  location="build"/>

    <import file="${ibis}/apps/satin/build-satin-app.xml"/>
</project>
\end{verbatim}
\end{quote}
Note that the assumption here is that Ibis is installed in
\verb+/usr/local/ibis+.

Now, invoking \emph{ant} compiles the application, leaving the class files
in a directory called \verb+build+.

Running a Satin program is very much like running an Ibis application.
See Section \ref{Compiling and Running an Ibis Application} for details.

\mysection{The GMI System}

TODO.

\mysection{Ibis RMI}

TODO: limitations/restrictions.

\mysection{Further Reading}

\end{document}
