\documentclass[10pt]{article}

\usepackage{html}

\newcommand{\mysection}[1]{\section{#1}\label{#1}}
\newcommand{\mysubsection}[1]{\subsection{#1}\label{#1}}
\newcommand{\mysubsubsection}[1]{\subsubsection{#1}\label{#1}}

\begin{document}

\title{
{\html {\htmladdnormallink{Ibis} {http://www.cs.vu.nl/ibis/}}}
{\latex {Ibis}}
Programmer's Manual}

\maketitle

\section{Introduction}

This manual describes how to write and run Ibis programs.
\begin{htmlonly}
It is also available in
\htmladdnormallink{postscript}{http://www.cs.vu.nl/ibis/progman.ps.gz}.
\end{htmlonly}
Ibis is a Java-centric grid programming environment.
It is described in several publications (see Section \ref{Further Reading}).
Rather than giving a detailed overview of what each class and method does,
the aim of this document is to describe how to actually use these classes
and methods.
The \emph{docs/api} subdirectory of the Ibis installation provides
documentation for each class and method.
Fragments of an actual Ibis application will be used for illustration purposes.
Section \ref{An Ibis Program} will discuss a typical Ibis program,
with subsections on each phase of the program.
Section \ref{Compiling and Running an Ibis Program} will discuss how to
actually compile and run this program.

We also built several systems on top of Ibis.
Section \ref{The Satin Divide-and-Conquer System}
gives an overview of the Satin divide-and-conquer
system, and Section \ref{The GMI System} discusses GMI
(Group Method Invocation),
a flexible group communication system.
We also built a (not quite complete) RMI (Remote Method Invocation)
implementation on top of Ibis. RMI documentation can be found on-line at
{\html {\htmladdnormallink{http://java.sun.com}{http://java.sun.com}}}
{\latex {http://java.sun.com}}.
 
\mysection{An Ibis Program}
An Ibis program consists of several parts:
\begin{itemize}
\item
Creating an Ibis in each instance of the program.
An Ibis program runs on multiple hosts. On each of these hosts, an Ibis
must be created.
\item
Setting up communication. Communication connections consist of so-called
send ports, through which messages can be sent, and receive ports, through
which messages can be received, and a connection between the two.
\item
Actually communicating. A send port can be used to create a so-called
write-message, which can be sent to the receive ports that this send port
is connected to.
\item
Finishing up. Connections must be closed, and each Ibis instance must
be ended.
\end{itemize}

The next few subsections will discuss each of these steps in turn,
illustrating them with parts of an RPC-style Ibis application.
This application will have a client and a server. As this is a toy
application, the server will have to compute the length of a string.
The client will send the string, and receive the result.
The server will have to do some other work as well, just to make
things a little more interesting.

\subsection{Preamble}

All Ibis programs import classes from the IPL (Ibis
Portability Layer) package, which lives in
\verb+ibis.ipl+.
So, the preamble of your program could just consist of one line:
\begin{quote}
\begin{verbatim}
import ibis.ipl.*;
\end{verbatim}
\end{quote}
It might also exist of an import of each class that is used,
but this might easily result in a list of 10 or more \verb+import+s.

\mysubsection{Creating an Ibis Instance}

All instances of a program that want to participate in an Ibis run
must create an Ibis instance.
To create an Ibis instance, the \verb+createIbis+ method of the
\verb+ibis.ipl.Ibis+ class must be used.
The specification of this method is:
\begin{quote}
\begin{verbatim}
Ibis createIbis(StaticProperties props,
                ResizeHandler h)
        throws IbisException;
\end{verbatim}
\end{quote}
There may be several Ibis implementations available, and the
idea is that the system selects the best one for you, based on some
user-specified requirements.
These requirements in fact tell the system what features must be supported
by the selected Ibis.
They are summarized in an object of the
\verb+ibis.ipl.StaticProperties+ class.
Below is a snippet from the RPC example:
\begin{quote}
\begin{verbatim}
StaticProperties props = new StaticProperties();
props.add("communication", "OneToOne, Reliable, " + 
                           "AutoUpcalls, ExplicitReceipt");
props.add("serialization", "object");
props.add("worldmodel", "closed");
\end{verbatim}
\end{quote}
This states that the selected Ibis must support reliable one-to-one
communication, must support upcalls at the receiver side without the
receiver having to poll for messages, and must also support explicit
receipt of messages at the receiver side.
(We want upcalls so that the server can do other work, and we want
explicit receipt for the client side).
In addition, the selected Ibis must support some form of object
serialization (a string must be sent),
and must support the "closed" worldmodel, which means
that all participating Ibises join at the start of the run, and a
synchronization takes place before \verb+createIbis+ returns.
(in the example we have a client and a server).

A complete list of property values is given below.
The possible property values of the "communication" property are:
\begin{description}
\item[OneToOne]
One-to-one (unicast) communication is supported (if an Ibis does not support
this, you may wonder what it \emph{does} support).
\item[OneToMany]
one-to-many (multicast) communication is supported.
(in Ibis terms: a sendport
may connect to multiple receiveports).
\item[ManyToOne]
many-to-one communication is supported (in Ibis terms: multiple
sendports may connect to a single receiveport).
\item[FifoOrdered]
messages from a send port are delivered to the receive ports it is
connected to in the order in which they were sent.
\item[TotallyOrdered]
receive ports receive all messages in the same order.
This is stronger than FifoOrdered, because not all messages have
to originate from the same send port.
\item[Reliable]
reliable communication is supported.
\item[Unreliable]
unreliable communication is explicitly supported.
\item[AutoUpcalls]
upcalls are supported and polling for them is not required.
This means that when a message arrives at a receive port, 
a user-specified upcall handler is invoked.
\item[PollUpcalls]
upcalls are supported but polling for them is required. When an
Ibis implementation claims that it has this, it may also do
AutoUpcalls but polling does no harm. When an application asks for
this (and not AutoUpcalls), it must poll.
\item[ExplicitReceipt]
explicit receive is supported.
This is the alternative way for receiving messages.
\item[ConnectionDowncalls]
connection downcalls are supported. This means that the user can
invoke methods to see which connections were lost or created.
\item[ConnectionUpcalls]
connection upcalls are supported. This means that un upcall
handler can be installed that is invoked whenever a new connection arrives
or a connection is lost.
\end{description}

The possible "serialization" properties are:
\begin{description}
\item[Byte]
readByte/writeByte and readArray/writeArray(byte[]) are supported.
\item[Data]
read/write and readArray/writeArray of primitive types are supported.
\item[Object]
Some sort of object serialization is supported. An Ibis implementation
will, of course, specify what kind of object serialization it supports.
The "Object" property allows a user to just ask for object
serialization, and not care if it is Ibis or Sun serialization.
\item[Ibis]
Ibis serialization is supported.
This is the fastest object serialization supported in Ibis. Its drawback
is that it does not support versioning, and does not support
non-symmetrical writeObject/readObject methods (where readObject does not
read everything that writeObject writes).
\item[Sun]
Sun serialization (through java.io.ObjectOutputStream/InputStream) is
supported.
\end{description}

The possible "worldmodel" properties are:
\begin{description}
\item[Open]
this means that Ibises can join the run at any time during the run.
\item[Closed]
this means that the Ibises that can join the run are determined
at the start of the run.
\end{description}

If a specific implementation of Ibis is required, that can be delt with too.
There is a property called "name", which can be used to supply a nickname
for the Ibis implementation that is required.
The currently known nicknames are:
\begin{description}
\item[tcp]
This is an Ibis implementation on top of TCP sockets, and currently is
probably the most stable Ibis around, and it supports almost all properties.
\item[panda]
This is a "messagePassing Ibis implementation on top of the Panda
communication layer. It only supports the "closed" worldmodel,
but on our system it gives much higher throughput and lower latencies
because it runs on Myrinet instead of our (100Mbitps) Ethernet on which
the tcp version runs.
\item[net]
This is the most flexible Ibis implementation, but still in an experimental
stage.
\item[nio]
This is a (still experimental) Ibis implementation on top of Java NIO.
\item[mpi]
This is the messagePassing Ibis implementation but on top of MPI instead
of Panda. This too is an experimental version.
\end{description}

A user running an Ibis application can override a property, or make it
more specific. This is done by means of Java system properties, which
in many Java implementations can be set by means of a command line option,
for instance -D\emph{property}=\emph{value}.
The system property name is that of the Ibis static property, prefixed
with "\verb+ibis.+".
So, adding \verb+-Dibis.serialization=ibis+ to the command line will
cause \verb+createIbis+ to look for an Ibis that supports ibis serialization
instead of any object serialization.

This completes the description of the first parameter
of \verb+createIbis+. The second parameter specifies an upcall handler
with \verb+join+ and \verb+leave+ upcalls that get called when an Ibis
joins or leaves the run.
In our RPC example, we will not use this, so we specify \verb+null+
instead.
So, with the \verb+props+ as defined above, we create an Ibis as follows:
\begin{quote}
\begin{verbatim}
try {
    Ibis ibis = createIbis(props, null);
} catch(NoMatchingIbisException e) {
    System.err.println("Could not find a matching Ibis");
    ...
}
\end{verbatim}
\end{quote}
Note that the properties can be so specific that no matching Ibis
can be found. Therefore, \verb+createIbis+ may throw an exception
indicating this.

\subsection{Setting up Communication}

Setting up communication consists of several steps:
\begin{itemize}
\item
create a port type;
\item
create a send and a receive port;
\item
setting up connections between them.
\end{itemize}

The next few subsections discuss each of these steps in turn.

\subsubsection{Creating a Port Type}

The next step is to create a so-called port type, from which
send and receive ports can be created. A port type is an object
of type \verb+ibis.ipl.PortType+.
Within an Ibis instance,
multiple port types, with different properties, can be created.
The properties of a port type are, like the required properties
of an Ibis, specified by a \verb+StaticProperties+ object.
A port type is identified by its name, together with these properties.
The \verb+Ibis+ class contains a method to create a port type,
specified as follows:
\begin{quote}
\begin{verbatim}
PortType createPortType(String name,
                        StaticProperties portprops)
        throws IbisException, java.io.IOException;
\end{verbatim}
\end{quote}

For our RPC example program, we would create a port type with properties
as discussed in Section \ref{Creating an Ibis Instance}:

\begin{quote}
\begin{verbatim}
StaticProperties portprops = new StaticProperties();
portprops.add("communication",
              "OneToOne, Reliable, " + 
                  "AutoUpcalls, ExplicitReceipt");
portprops.add("serialization", "object");
PortType porttype = null;
try {
    porttype = ibis.createPortType("RPC port", portprops);
} catch(Exception e) {
    ...
}
\end{verbatim}
\end{quote}

In general, the port properties should be a subset of the properties
specified when creating the Ibis instance. If a property is specified
that was not specified when creating the Ibis instance, this could
result in an \verb+IbisException+.
An \verb+IbisException+ could also result when the same name is
already used for a port type with different properties.
Port types are registered with an internal or external name server
(this will be discussed in Section \ref{Compiling and Running an Ibis Program}).
If communication with this name server fails, a
\verb+java.io.IOException+ is thrown.

\subsubsection{Which Instance Does What?}

Up until now, we have discussed only matters that all instances of
the Ibis application should do, but now, things become different.
One instance of the application may want to send messages, while
another instance may want to receive them.
It may not even be clear which instance is going to do what.
This can of course be solved with program parameters, but Ibis
also provides a so-called registry (of type
\verb+ibis.ipl.Registry+), which is obtained through the
\verb+ibis.regstry+ method.
Ibis also provides the \verb+ibis.ipl.IbisIdentifier+ class.
the \verb+ibis.ipl.Ibis.identifier+ method returns such an
Ibis identifier, which identifies this specific Ibis instance.
Now it is possible to decide, in the RPC example, who is going
to be the server by means of an "election": the Ibis registry
provides a method \verb+elect+ which (globally) selects one of
a number of invokers.
For our RPC example this would go as follows:

\begin{quote}
\begin{verbatim}
IbisIdentifier me = ibis.identifier();
Registry registry = ibis.registry();
IbisIdentifier server = (IbisIdentifier)
                          registry.elect("Server", me);
boolean i_am_server = server.equals(me);
\end{verbatim}
\end{quote}

It could also be that the client and the server are separate programs.

\subsubsection{Creating Send and Receive Ports}

The \verb+PortType+ class contains several variants of a method
\verb+createSendPort+ that creates a send port (of type
\verb+ibis.ipl.SendPort+) and
also several variants of a method \verb+createReceivePort+ that
creates a receive port (of type \verb+ibis.ipl.ReceivePort+),
See the API for an exhaustive list of variants.

In Ibis, receive ports usually have specific names, so that
a send port can set up a connection to a receive port. In contrast,
send ports usually are anonymous, because a receive port cannot
initiate a connection.

For our RPC example, the server will have to create a receive port
to receive a request and a send port to send an answer.
The server is not allowed to block waiting for a request, so it will
want a receive port that enables upcalls.
To do that, the server must first define a class that implements
the \verb+ibis.ipl.Upcall+ interface. This interface contains one
method:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws java.io.IOException;
\end{verbatim}
\end{quote}

We will go into the details of a \verb+ReadMessage+ in Section
\ref{Communicating}. For now, we will assume that there is a
class \verb+RPC_Upcall+ that implements this interface, and
a field \verb+rpc_upcall+ of this type.

\begin{quote}
\begin{verbatim}
try {
    SendPort server_sender = porttype.createSendPort();
    ReceivePort server_receiver =
        porttype.createReceivePort("server", rpc_upcall);
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

The client will have to create a send port
to send a request and a receive port to receive an answer.
The client is allowed to block waiting for an answer, so it will
want a receive port that enables explicit receipt.
So, the client will create an anonymous server port, and a named
receive port that enables explicit receipt:

\begin{quote}
\begin{verbatim}
try {
    SendPort client_sender = porttype.createSendPort();
    ReceivePort client_receiver =
        porttype.createReceivePort("client");
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

\subsubsection{Setting Up a Connection}

Now that we have send ports and receive ports, it is time to set up
connections between them.
A connection is initiated by the \verb+connect+ method of
\verb+ibis.ipl.SendPort+.
Here is its specification:

\begin{quote}
\begin{verbatim}
void connect (ReceivePortIdentifier r) throws IOException;
\end{verbatim}
\end{quote}

This version blocks until an accept or deny is received, and throws
an \verb+IOException+ when the connection could not be established.
There also is a \verb+connect+ version with a time-out.

So, we need a \verb+ibis.ipl.ReceivePortIdentifier+ to set up the
connection.
This identifier can be obtained through the Ibis registry, by
means of the \verb+lookup+ method, which has the following specification:

\begin{quote}
\begin{verbatim}
ReceivePortIdentifier lookup(String name)
        throws IOException;
\end{verbatim}
\end{quote}

This method blocks until a receive port with the specified name is found.
Our RPC server would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier clnt = registry.lookup("client");
    server_sender.connect(clnt);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

Our RPC client would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier srvr = registry.lookup("server");
    client_sender.connect(srvr);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

This completes the connection setup.

Note that a send port can set up connections to more than one
receive port (if the port type supports the \verb+OneToMany+
communication property). Also, multiple send ports can set up
connections to the same receive port (if the port type supports
the \verb+ManyToOne+ communication property).

\mysubsection{Communicating}

As the reader may have noticed by now, communication in Ibis
consists of messages, sent from a send port, and received at a
receive port. When a sender wants to send a message, it will first
have to obtain one from the send port. Such a message is of
type \verb+ibis.ipl.WriteMessage+ and is obtained by means of
the \verb+newMessage+ method of \verb+SendPort+, which is specified
as follows:

\begin{quote}
\begin{verbatim}
WriteMessage newMessage() throws IOException;
\end{verbatim}
\end{quote}

For a given send port, only one message can be alive at any time.
When a new message is requested while a message is alive, the request
is blocked until the live message is finished.

Once a write message is obtained, data can be written to it.
A write message has various methods for the different types of
data that can be written to it. For instance, the
\verb+writeInt+ method can be used to write an integer value,
and the \verb+writeObject+ method can be used to write an object.
The kind of data that can be written to the message depends on the
serialization property specified when the port type was created.
The most general form is object serialization, which supports 
all write methods in a write message.
The \verb+data+ serialization property does not allow use of the
\verb+writeObject+ method, but does allow the use of all other write
methods. The \verb+byte+ serialization property only allows use
of the \verb+writeByte+ method and the \verb+writeArray(byte[])+
method.

Once there is a considerable amount of data in the message, Ibis
can be given a hint to start sending, using the \verb+send()+
method. This hint is not needed, however. When the message is
complete, the message can be sent out by invoking the
\verb+finish()+ method.

Our client in the RPC example could have the following:
\begin{quote}
\begin{verbatim}
int obtainLength(String s) throws IOException {
    WriteMessage w = client_sender.newMessage();
    w.writeObject(s);
    w.finish();
    ...
\end{verbatim}
\end{quote}

At the receiving side, a message can be received in two ways,
depending on how the receive port was created: either by means of an
upcall, or by means of an explicit receive. For each write method
in a write message, there is a corresponding read method in
a read message. For a given receive port, only one message can
be alive at any time. A read message is alive until it is
finished (by a \verb+finish+ call), or the upcall returns.

Now, let us present some more code of our RPC example, this time
from the server:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws IOException {
    String s = (String) m.readObject();
    int len = s.length;
    m.finish();
    WriteMessage w = server_sender.newMessage();
    w.writeInt(len);
    w.finish();
}
\end{verbatim}
\end{quote}

Note that the read message is finished before replying to the
request. To prevent deadlocks, upcalls are not allowed to block in
condition sychronization or network access as long as the message
is active.

Now, we can also finish the \verb+obtainLength+ method of the client:
\begin{quote}
\begin{verbatim}
    ...
    ReadMessage r = client_receiver.receive();
    int len = r.readInt();
    r.finish();
    return len;
}
\end{verbatim}
\end{quote}

\subsection{Finishing up}

Closing of a connection is initiated by closing a send port
(by means of the \verb+close+) method. The \verb+ReceivePort+
class also has a \verb+close+ method, but this method blocks
until all send ports that have a connection to it are closed.
So, send ports have to be closed first.

Our RPC client will do the following:

\begin{quote}
\begin{verbatim}
client_sender.close();
client_receiver.close();
\end{verbatim}
\end{quote}
and the code of the server should be clear by now.

Ibis itself must also be ended. Both our client and our server
should invoke the \verb+Ibis.end+ method:
\begin{quote}
\begin{verbatim}
ibis.end();
\end{verbatim}
\end{quote}

As of Java 1.4, it is also possible to add a so-called shutdown hook.
This could be done right after the Ibis instance is created:
\begin{quote}
\begin{verbatim}
Runtime.getRuntime().addShutdownHook(new Thread() {
    public void run() {
        try {
            ibis.end();
        } catch (IOException e) {
        }
    }
});
\end{verbatim}
\end{quote}

This shutdown hook gets invoked when the program terminates.

\mysection{Compiling and Running an Ibis Program}

Before running an Ibis application it must be compiled.

\mysection{The Satin Divide-and-Conquer System}

\mysection{The GMI System}

\mysection{Further Reading}

\end{document}
