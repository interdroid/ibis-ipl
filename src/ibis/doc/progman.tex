\documentclass[10pt]{article}

\usepackage{html}

\newcommand{\mysection}[1]{\section{#1}\label{#1}}
\newcommand{\mysubsection}[1]{\subsection{#1}\label{#1}}
\newcommand{\mysubsubsection}[1]{\subsubsection{#1}\label{#1}}
\newcommand{\remark}[1]{[\emph{#1}]}

\begin{document}

\title{
{\html {\htmladdnormallink{Ibis} {http://www.cs.vu.nl/ibis/}}}
{\latex {Ibis}}
Programmer's Manual}

\author{The Ibis Group}

\maketitle

\section{Introduction}

This manual describes how to write and run Ibis applications.
\html{
It is also available in
\htmladdnormallink{postscript}{http://www.cs.vu.nl/ibis/progman.ps.gz}.}
\latex{It is available on-line at http://www.cs.vu.nl/ibis/progman/.}
Ibis is a Java-centric grid programming environment.
It is described in several publications (see Section \ref{Further Reading}).
Rather than giving a detailed overview of what each class and method does,
the aim of this document is to describe how to actually use these classes
and methods.
The \emph{docs/api} subdirectory of the Ibis installation provides
documentation for each class and method (point your favorite HTML viewer
to docs/api/index.html file of the Ibis installation).
The Ibis API is also available
\html{\htmladdnormallink{on-line}{http://www.cs.vu.nl/ibis/api/index.html}.}
\latex{on-line at http://www.cs.vu.nl/ibis/api/index.html.}
Fragments of an actual Ibis application will be used for illustration purposes.
Section \ref{An Ibis Application} will discuss a typical Ibis application,
with subsections on each phase of the program.
Section \ref{Compiling and Running an Ibis Application} will discuss how to
actually compile and run this program.

We also built several systems on top of Ibis.
Section \ref{The Satin Divide-and-Conquer System}
gives an overview of the Satin divide-and-conquer
system, and Section \ref{The GMI System} discusses GMI
(Group Method Invocation),
a flexible group communication system.
We also built a RMI (Remote Method Invocation)
implementation on top of Ibis. RMI documentation can be found at
{\html {\htmladdnormallink{http://java.sun.com/j2se/1.4.2/docs/guide/rmi/index.html}{http://java.sun.com/j2se/1.4.2/docs/guide/rmi/index.html}}}
{\latex {http://java.sun.com/j2se/1.4.2/docs/guide/rmi/index.html}}.
Section \ref{Ibis RMI} briefly discusses the Ibis RMI implementation.

\mysection{Some Ibis concepts}

\mysubsection{The Ibis Portability Layer}

The top layer of the Ibis system consists of the Ibis Portability Layer (IPL).
The IPL consists of a set of Java interfaces that define how an Ibis application
can make use of the Ibis components.
The Ibis application does not need to know which specific Ibis implementations are
available.
It just specifies some properties that it requires, and the Ibis system
selects the best available Ibis implementation that meets these requirements.
 
\mysubsection{An Ibis Instance}

A loaded Ibis implementation is called an \emph{Ibis instantiation}, or 
\emph{Ibis instance}.
An Ibis instance is identified by a so-called
\emph{Ibis identifier}.
An application can find out which Ibis instances are present in the run
by supplying a so-called \emph{ResizeHandler}.
This ResizeHandler is an object with, among others, a \texttt{join()}
method which gets called by the Ibis system when a new Ibis instance
joins the run.  The Ibis identifier of this new Ibis is a parameter
to the \texttt{join()} method.

\mysubsection{Send Ports and Receive Ports}

The IPL provides primitives to communicate between send and receive ports.
In general a connection can be between multiple send ports and multiple
receive ports, but the user may specify that a connection will have only
a single send or receive port, allowing Ibis to choose a more efficient
implementation.  A connection is always \emph{unidirectional}; reverse
connections are conceptually totally independent.

All send and receive ports have a \emph{type} which is represented by an
instance of \texttt{ibis.ipl.PortType}. A port type is associated
with communication properties such as serialization method used, message
ordering, restriction to a single send or receive port, et cetera. The
types are also useful for verification purposes in the application.
Only ports of the same type can be connected.

To create a connection, an Ibis application requests new send and receive
ports from a port type, and requests that a connection is set up 
between these ports.

To send a message, the Ibis application requests a new write message from
a send port, puts data in this write message using the provided methods,
and invokes the \texttt{finish()} method to send the message.

To receive a message, the IPL provides two mechanisms:
\begin{description}
\item[explicit receipt]
when a receive port is configured for explicit receipt, a message can be
received with the receive port's blocking \emph{receive} method,
or with its non-blocking \emph{poll} method.
These methods return a \emph{read message} object, from which data can
be extracted using its read methods. The \emph{poll} method may also
return \emph{null}, in case no message is available.
\item[upcalls]
when a receive port is configured for upcalls, the Ibis application provides
an \emph{upcall} method, which is to be called when a message arrives.
The upcall provides the message received as a parameter.
The message contents will be lost when the upcall returns, so the data
in the message must be read in the upcall.
Upcalls are either automatic, or must be polled for explicitly, see Section
\ref{Creating an Ibis Instance}.
\end{description}
\noindent

\mysubsection{Port Types}

Send and receive ports are \emph{typed} by means of a \emph{port type}.
A port type is defined and configured with properties.
Only ports of the same type can be connected.
Port type properties that can be configured are, for instance, the
serialization method used, reliability, whether a send port can connect
to more than one receive port, whether more than one send port can connect
to a single receive port, et cetera.

\mysubsection{Serialization}

Serialization is a mechanism for converting Java objects
into portable data that can be stored or transferred.
Java has input
(\texttt{java.io.ObjectInputStream})
and output
(\texttt{java.io.ObjectOutputStream})
streams for reading and writing
objects.
In Ibis, we call this mechanism \emph{Sun serialization}.
Ibis also has its own mechanism, which is completely compatible (with
regard to its interface) with Sun serialization, but more efficient.
We call this mechanism \emph{Ibis serialization}.

Sometimes, object serialization is not needed. For that case,
two simpler serialization mechanisms are available: \emph{data
serialization} which allows for sending/receiving data of basic types
and arrays of basic types (similar to \texttt{java.io.DataInputStream}
and \texttt{java.io.DataOutputStream}), and \emph{byte serialization}
which only allows sending/receiving bytes and arrays of bytes.

\mysection{An Ibis Application}

An Ibis application consists of several parts:
\begin{itemize}
\item
Creating an Ibis in each instance of the application.
An Ibis application can run on multiple hosts.
On each of these hosts, an Ibis must be created.
\item
Setting up communication. Communication setup in Ibis
consists of creating one or more \emph{send ports}, through which messages
can be sent, and creating one or more \emph{receive ports},
through which messages can be received, and creating connections between them.
\item
Actually communicating. A send port is used to create a 
\emph{write message}, which is sent to the receive ports that this send port
is connected to.
\item
Finishing up. Connections must be closed, and each Ibis instance must
be ended.
\end{itemize}
\noindent
The next few subsections will discuss each of these steps in turn,
illustrating them with parts of an RPC-style Ibis application.
This application will have a client and a server. As this is a toy
application, the server will have to compute the length of a string.
The client will send the string, and receive the result.
The server will have to do some other work as well, just to make
things a little more interesting.

\subsection{Program Preamble}

Ibis applications need to import classes from the IPL (Ibis
Portability Layer) package, which lives in
\texttt{ibis.ipl}.
We recommend that you simply import all \texttt{ibis.ipl} classes with
one import line:
\begin{quote}
\begin{verbatim}
import ibis.ipl.*;
\end{verbatim}
\end{quote}
Of course it is also possible to import only the needed classes, but
this tends to result in a list of 10 or more \texttt{import}s.

\mysubsection{Creating an Ibis Instance}

All instances of a program that want to participate in an Ibis run
must create an Ibis instance.
To create an Ibis instance, the \texttt{createIbis()} method of the
\texttt{ibis.ipl.Ibis} class must be used.
The specification of this method is:
\begin{quote}
\begin{verbatim}
Ibis createIbis(StaticProperties props,
                ResizeHandler h)
        throws IbisException;
\end{verbatim}
\end{quote}
There may be several Ibis implementations available, and
the system selects the best one for you, based on some
user-specified requirements.
These requirements tell the system what features must be supported
by the selected Ibis.
They are summarized in an object of the
\texttt{ibis.ipl.StaticProperties} class, as discussed in Section
\ref{StaticProperties}

The second parameter of \texttt{createIbis()} specifies an upcall handler
with \texttt{join} and \texttt{leave} upcalls that get called when an Ibis
joins or leaves the run.  In our RPC example, we will not use this, so we
specify \texttt{null} instead.  However, when such a \texttt{ResizeHandler}
is used, its \texttt{join} upcall is called for every Ibis that joins the
run, including the Ibis being created itself.
Upcalls to the \texttt{ResizeHandler} must be explicitly enabled by
invoking the \texttt{openWorld()} method of the Ibis
just created. This ensures that the \texttt{ResizeHandler} has been
able to do the necessary initializations.

The \texttt{openWorld()} method blocks until the
\texttt{join} upcall for this Ibis has been invoked.  Knowing which Ibises
have joined the run, and how many there are, is often useful in dividing
the work. See also section \ref{Which Instance Does What?}.

Now back to our example. In Secion \ref{StaticProperties} we will
discuss the creation of a variable \texttt{props} describing the
static properties required. For the moment we will just assume its
existence, and create an Ibis as follows:
\begin{quote}
\begin{verbatim}
try {
    Ibis ibis = createIbis(props, null);
} catch(NoMatchingIbisException e) {
    System.err.println("Could not find a matching Ibis");
    ...
}
\end{verbatim}
\end{quote}
Note that the properties can be so specific that no matching Ibis
can be found, and therefore \texttt{createIbis} may throw an exception
indicating this.

\mysubsection{StaticProperties}

Below is a snippet from the RPC example, constructing the static
properties as required:
\begin{quote}
\begin{verbatim}
StaticProperties props = new StaticProperties();
props.add("communication", "OneToOne, Reliable, " + 
                           "AutoUpcalls, ExplicitReceipt");
props.add("serialization", "object");
props.add("worldmodel", "closed");
\end{verbatim}
\end{quote}
This states that the selected Ibis must support reliable one-to-one
communication, must support upcalls at the receiver side without the
receiver having to poll for messages, and must also support explicit
receipt of messages at the receiver side.
(We want upcalls so that the server can do other work, and we want
explicit receipt for the client side).
In addition, the selected Ibis must support some form of object
serialization (a string must be sent),
and must support the ``closed'' worldmodel, which means
that all participating Ibises join at the start of the run, and a
synchronization takes place before \texttt{createIbis} returns.
(in the example we have a client and a server).

A complete list of property values is given below.
The possible property values of the ``communication'' property are
(capitals are not significant):
\begin{description}
\item[OneToOne]
One-to-one (unicast) communication is supported (if an Ibis does not support
this, you may wonder what it \emph{does} support).
\item[OneToMany]
one-to-many (multicast) communication is supported.
(in Ibis terms: a sendport
may connect to multiple receiveports).
\item[ManyToOne]
many-to-one communication is supported (in Ibis terms: multiple
sendports may connect to a single receiveport).
\item[FifoOrdered]
messages from a send port are delivered to the receive ports it is
connected to in the order in which they were sent.
\item[Numbered]
all messages originating from any send port of a specific port type have
a sequence number. This allows the application to do its own sequencing.
\item[Reliable]
reliable communication is supported, that is,
a reliable communication protocol is used.
When not specified, an Ibis may be chosen that does not explicitly
support reliable communication.
\item[AutoUpcalls]
upcalls are supported and polling for them is not required.
This means that when the user creates a receiveport with an upcall
handler installed, when a message arrives at that receive port, 
this upcall handler is invoked automatically.
\item[PollUpcalls]
upcalls are supported but polling for them may be needed. When an
Ibis implementation claims that it supports this, it may also do
AutoUpcalls, but polling does no harm. When an application asks for
this (and not AutoUpcalls), it must poll.
\item[ExplicitReceipt]
explicit receive is supported.
This is the alternative way to upcalls for receiving messages.
\item[ConnectionDowncalls]
connection downcalls are supported. This means that the user can
invoke methods to see which connections were lost or created.
\item[ConnectionUpcalls]
connection upcalls are supported. This means that an upcall
handler can be installed that is invoked whenever a new connection arrives
or a connection is lost.
\end{description}

The possible ``serialization'' properties are:
\begin{description}
\item[Byte]
Only the methods \texttt{readByte()}, \texttt{writeByte()}, \texttt{readArray(byte[])} and \texttt{writeArray(byte[])} are supported.
\item[Data]
Only \texttt{read()}/\texttt{write()} and \texttt{readArray()}/\texttt{writeArray()} of primitive types are supported.
\item[Object]
Some sort of object serialization is supported. An Ibis implementation
will, of course, specify what kind of object serialization it supports.
The ``Object'' property allows a user to just ask for object
serialization, and not care if it is Ibis or Sun serialization.
\item[Ibis]
Ibis serialization is supported.
This is the fastest object serialization supported in Ibis. Its drawback
is that it requires identical Java implementations on sender and
receiver side, and does not support
non-symmetrical \texttt{writeObject()}/\texttt{readObject()} methods (where readObject does not
read everything that writeObject writes).
\item[Sun]
Sun serialization (through java.io.ObjectOutputStream/InputStream) is
supported.
\end{description}

\noindent
The possible ``worldmodel'' properties are:
\begin{description}
\item[Open]
Ibises can join the run at any time during the run.
\item[Closed]
Ibises can only join the run at the start.
\end{description}

\noindent
If a specific implementation of Ibis is required, that can be dealt with too.
There is a property called ``name'', which can be used to supply a nickname
for the Ibis implementation that is required.
The currently known nicknames are:
\begin{description}
\item[tcp]
This is an Ibis implementation on top of TCP sockets. It is currently 
probably the most stable Ibis around, and it supports almost all properties.
\item[panda]
This is a message passing Ibis implementation on top of the Panda
communication layer. It only supports the ``closed'' worldmodel,
but on our system it gives much higher throughput and lower latencies
because it runs on Myrinet instead of our (100Mbitps) Ethernet on which
the TCP version runs.
\item[net]
This is the most flexible Ibis implementation, but still in an experimental
stage.
\item[nio]
This is a (still experimental) Ibis implementation on top of Java NIO.
\item[mpi]
This is the message passing Ibis implementation but on top of MPI instead
of Panda. This too is an experimental version.
\end{description}

\noindent
A user running an Ibis application can override a property, or make
it more specific. This is done by means of Java system properties,
which in many Java implementations can be set by means of a command
line option.  For instance, JVMs support options of the form
-D\emph{property}=\emph{value}.  The system property name is that
of the Ibis static property, prefixed with ``\texttt{ibis.}''.  So,
adding \texttt{-Dibis.serialization=ibis} to the command line will cause
\texttt{createIbis} to look for an Ibis that supports Ibis serialization
instead of any object serialization.

\subsection{Setting up Communication}

Setting up communication consists of several steps:
\begin{itemize}
\item
create a port type;
\item
create a send and a receive port;
\item
set up connections between them.
\end{itemize}

\noindent
The next few subsections discuss each of these steps in turn, but
first we will discuss how to decide which Ibis instance does what.

\mysubsubsection{Which Instance Does What?}

Up until now, we have discussed only matters that all instances of
the Ibis application should do, but now things become different.
One instance of the application may want to send messages, while
another instance may want to receive them.
It may not even be clear which instance is going to do what.
This can of course be solved with program parameters, but Ibis
also provides a so-called registry (of type
\texttt{ibis.ipl.Registry}), which is obtained through the
\texttt{ibis.registry()} method.
Ibis also provides the \texttt{ibis.ipl.IbisIdentifier} class.
The \texttt{ibis.ipl.Ibis.identifier()} method returns such an
Ibis identifier, which identifies this specific Ibis instance.

Using these methods it is possible to decide, in the RPC example,
who is going to be the server by means of an ``election'': the Ibis
registry provides a method \texttt{elect()} which (globally) selects
one of a number of invokers.  For our RPC example this could be done as
follows:

\begin{quote}
\begin{verbatim}
IbisIdentifier me = ibis.identifier();
Registry rgstry = ibis.registry();
IbisIdentifier server = (IbisIdentifier)
                          rgstry.elect("Server", me);
boolean i_am_server = server.equals(me);
\end{verbatim}
\end{quote}

In our example one instance of the program is the server, and all
others are clients.  Of course, the client and the server can also
be different programs.

The \texttt{ResizeHandler}, as discussed in Section
\ref{Creating an Ibis Instance}, can be used to keep track of the number
of Ibis instances currently involved in the run.

\subsubsection{Creating a Port Type}

To be able to create send and receive ports, it is first necessary
to create one or more \emph{port types}.
A port type is an object
of type \texttt{ibis.ipl.PortType}.
Within an Ibis instance,
multiple port types, with different properties, can be created.
The properties of a port type are, like the required properties
of an Ibis, specified by a \texttt{StaticProperties} object.
A port type is identified by its name, together with these properties.
The \texttt{Ibis} class contains a method to create a port type,
specified as follows:
\begin{quote}
\begin{verbatim}
PortType createPortType(String name,
                        StaticProperties portprops)
        throws IbisException, java.io.IOException;
\end{verbatim}
\end{quote}

\noindent
For our RPC example program, we would create a port type with properties
as discussed in Section \ref{Creating an Ibis Instance}:

\begin{quote}
\begin{verbatim}
StaticProperties portprops = new StaticProperties();
portprops.add("communication",
              "OneToOne, Reliable, " + 
                  "AutoUpcalls, ExplicitReceipt");
portprops.add("serialization", "object");
PortType porttype = null;
try {
    porttype = ibis.createPortType("RPC port", portprops);
} catch(Exception e) {
    ...
}
\end{verbatim}
\end{quote}
\noindent
In general, the port properties should be a subset of the properties
specified when creating the Ibis instance. If a property is specified
that was not specified when creating the Ibis instance, this could
result in an \texttt{IbisException}.
An \texttt{IbisException} could also result when the same name is
already used for a port type with different properties.
Port types are registered with a name server
(this will be discussed in Section \ref{Compiling and Running an Ibis Application}).
If communication with this name server fails, a
\texttt{java.io.IOException} is thrown.

\subsubsection{Creating Send and Receive Ports}

The \texttt{PortType} class contains several variants of a method
\texttt{createSendPort()} that creates a send port (of type
\texttt{ibis.ipl.SendPort}) and
also several variants of a method \texttt{createReceivePort()} that
creates a receive port (of type \texttt{ibis.ipl.ReceivePort}),
See the API for an exhaustive list of variants.

In Ibis, receive ports usually have specific names, so that
a send port can set up a connection to a receive port. In contrast,
send ports usually are anonymous, because a receive port cannot
initiate a connection.

For our RPC example, the server will have to create a receive port
to receive a request and a send port to send an answer.
The server is not allowed to block waiting for a request, so it will
want a receive port that enables upcalls.
To do that, the server must first define a class that implements
the \texttt{ibis.ipl.Upcall} interface. This interface contains one
method:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws java.io.IOException;
\end{verbatim}
\end{quote}

We will go into the details of a \texttt{ReadMessage} in Section
\ref{Communicating}. For now, we will assume that there is a
class \texttt{RpcUpcall} that implements this interface, and
a field \texttt{rpcUpcall} of this type.

\begin{quote}
\begin{verbatim}
try {
    SendPort serverSender = porttype.createSendPort();
    ReceivePort serverReceiver =
        porttype.createReceivePort("server", rpcUpcall);
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

\noindent
The client will have to create a send port
to send a request and a receive port to receive an answer.
The client is allowed to block waiting for an answer, so it will
want a receive port that enables explicit receipt.
So, the client will create an anonymous server port, and a named
receive port that enables explicit receipt (no upcall handler is supplied):
\begin{quote}
\begin{verbatim}
try {
    SendPort clientSender = porttype.createSendPort();
    ReceivePort clientReceiver =
        porttype.createReceivePort("client");
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

\noindent
When a receive port is created, it will not immediately accept connections.
This must be explicitly enabled by
invoking the \texttt{enableConnections()} method. So, the creator of
the receive port can determine when he is ready to accept connections.
If the receive port is configured for upcalls, these must
explicitly be enabled by invoking the \texttt{enableUpcalls()} method.

\subsubsection{Setting Up a Connection}

Now that we have send ports and receive ports, it is time to set up
connections between them.
A connection is initiated by the \texttt{connect()} method of
\texttt{ibis.ipl.SendPort}.
Here is its specification:

\begin{quote}
\begin{verbatim}
void connect (ReceivePortIdentifier r) throws IOException;
\end{verbatim}
\end{quote}

\noindent
This version blocks until an accept or deny is received, and throws
an \texttt{IOException} when the connection could not be established.
There also is a \texttt{connect} version with a time-out.

So, we need a \texttt{ibis.ipl.ReceivePortIdentifier} to set up the
connection.
This identifier can be obtained through the Ibis registry, by
means of the \texttt{lookup()} method, which has the following specification:

\begin{quote}
\begin{verbatim}
ReceivePortIdentifier lookup(String name)
        throws IOException;
\end{verbatim}
\end{quote}
\noindent
This method blocks until a receive port with the specified name is found.
Our RPC server would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier client = rgstry.lookup("client");
    serverSender.connect(client);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

\noindent
Our RPC client would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier srvr = rgstry.lookup("server");
    clientSender.connect(srvr);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

This completes the connection setup.

Note that a send port can set up connections to more than one
receive port (if the port type supports the \texttt{OneToMany}
communication property). Also, multiple send ports can set up
connections to the same receive port (if the port type supports
the \texttt{ManyToOne} communication property).

\mysubsection{Connection upcalls, connection downcalls}

Sometimes it is useful for an application to know which send ports
are connected to a receive port, and vice versa, or which connections
are being closed.
Ibis implementations may support two different mechanisms for obtaining
this type of information: connection upcalls and connection downcalls.

When a port type is configured for using connection upcalls,
a receive port may be instantiated with a \texttt{ReceivePortConnectUpcall}
object. This is an interface with two methods:

\begin{quote}
\begin{verbatim}
boolean gotConnection(ReceivePort me,
                      SendPortIdentifier applicant);
void lostConnection(ReceivePort me,
                    SendPortIdentifier johndoe,
                    Exception reason);
\end{verbatim}
\end{quote}
\noindent 
The \texttt{gotConnection()} method gets called when a send port attempts
to connect to the receive port at hand.
An implementation of this method can decide whether
to allow this connection or not.
The \texttt{lostConnection()} method gets called when an existing connection
to the receive port at hand gets lost for some reason.

A send port can be instantiated with a
\texttt{SendPortConnectUpcall} object. This is an interface with a single method:

\begin{quote}
\begin{verbatim}
void lostConnection(SendPort me,
                    ReceivePortIdentifier johndoe,
                    Exception reason);
\end{verbatim}
\end{quote}
\noindent 
This method is called when an existing connection from the send port at
hand gets lost for some reason. Note that there is no \texttt{gotConnection}
counterpart, because it is always the send port that initiates a connection.

When a port type is configured for using connection downcalls, receive ports
and send ports of this type maintain connection information.
A receive port has the following methods:

\begin{quote}
\begin{verbatim}
SendPortIdentifier[] newConnections();
SendPortIdentifier[] lostConnections();
SendPortIdentifier[] connectedTo();
\end{verbatim}
\end{quote}

\texttt{newConnections} returns the send port identifiers of the connections
that are new since the last call or the start of the program.
\texttt{lostConnections} returns the send port identifiers of the connections
that were lost since the last call or the start of the program.
\texttt{connectedTo} returns the send port identifiers of all connections
to this receive port.
A send port has the following methods:

\begin{quote}
\begin{verbatim}
ReceivePortIdentifier[] newConnections();
ReceivePortIdentifier[] lostConnections();
ReceivePortIdentifier[] connectedTo();
\end{verbatim}
\end{quote}
\noindent
\texttt{newConnections} returns the receive port identifiers of the connections
that are new since the last call or the start of the program.
\texttt{lostConnections} returns the receive port identifiers of the connections
that were lost since the last call or the start of the program.
\texttt{connectedTo} returns the receive port identifiers of all connections
from this send port.

\mysubsection{Communicating}

As the reader may have noticed by now, communication in Ibis
consists of messages, sent from a send port, and received at a
receive port. When a sender wants to send a message, it will first
have to obtain one from the send port. Such a message is of
type \texttt{ibis.ipl.WriteMessage} and is obtained by means of
the \texttt{newMessage()} method of \texttt{SendPort}, which is specified
as follows:

\begin{quote}
\begin{verbatim}
WriteMessage newMessage() throws IOException;
\end{verbatim}
\end{quote}

\noindent
For a given send port, only one message can be alive at any time.
When a new message is requested while a message is alive, the request
is blocked until the live message is finished.

Once a write message is obtained, data can be written to it.
A write message has various methods for the different types of
data that can be written to it. For instance, the
\texttt{writeInt()} method can be used to write an integer value,
and the \texttt{writeObject()} method can be used to write an object.
The kind of data that can be written to the message depends on the
serialization property specified when the port type was created.
The most general form is object serialization, which supports 
all write methods in a write message.
The \texttt{data} serialization property does not allow use of the
\texttt{writeObject()} method, but does allow the use of all other write
methods. The \texttt{byte} serialization property only allows use
of the \texttt{writeByte()} method and the \texttt{writeArray(byte[])}
method.

Once there is a considerable amount of data in the message, Ibis
can be given a hint to start sending, using the \texttt{send()}
method. This hint is not needed, however. When the message is
complete, the message can be sent out by invoking the
\texttt{finish()} method.

Our client in the RPC example could have the following:
\begin{quote}
\begin{verbatim}
int obtainLength(String s) throws IOException {
    WriteMessage w = clientSender.newMessage();
    w.writeObject(s);
    w.finish();
    ...
}
\end{verbatim}
\end{quote}

\noindent
At the receiving side, a message can be received in two ways,
depending on how the receive port was created: either by means of an
upcall, or by means of an explicit receive. For each write method
in a write message, there is a corresponding read method in
a read message. For a given receive port, only one message can
be alive at any time. A read message is alive until it is
finished (by a \texttt{finish} call), or the upcall returns.

Now, let us present some more code of our RPC example, this time
from the server:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws IOException {
    String s = (String) m.readObject();
    int len = s.length;
    m.finish();
    WriteMessage w = serverSender.newMessage();
    w.writeInt(len);
    w.finish();
}
\end{verbatim}
\end{quote}

\noindent
Note that the read message is finished before replying to the
request. To prevent deadlocks, upcalls are not allowed to block
(call \texttt{Thread.wait}) or access the network (write a message or
read another message) as long as a read message is active.

Now, we can also finish the \texttt{obtainLength} method of the client:
\begin{quote}
\begin{verbatim}
    ...
    ReadMessage r = clientReceiver.receive();
    int len = r.readInt();
    r.finish();
    return len;
}
\end{verbatim}
\end{quote}

\subsection{Finishing up}

Closing of a connection is initiated by closing a send port
by means of the \texttt{close()} method. The \texttt{ReceivePort}
class also has a \texttt{close()} method, but this method blocks
until all send ports that have a connection to it are closed.
So, send ports have to be closed first.

Our RPC client will do the following:

\begin{quote}
\begin{verbatim}
clientSender.close();
clientReceiver.close();
\end{verbatim}
\end{quote}
and the code of the server should be clear by now.

Ibis itself must also be ended. Both our client and our server
should invoke the \texttt{Ibis.end()} method:
\begin{quote}
\begin{verbatim}
ibis.end();
\end{verbatim}
\end{quote}

As of Java 1.3, it is also possible to add a so-called shutdown hook.
This could be done right after the Ibis instance is created:
\begin{quote}
\begin{verbatim}
Runtime.getRuntime().addShutdownHook(new Thread() {
    public void run() {
        try {
            ibis.end();
        } catch (IOException e) {
        }
    }
});
\end{verbatim}
\end{quote}
\noindent
This shutdown hook gets invoked when the program terminates, and
forcibly closes all ports.

\mysubsection{Ibis utilities}

The \texttt{ibis.util} package contains several utilities that may be
useful for Ibis applications. We will discuss some of them here.

\mysubsubsection{PoolInfo}

The \texttt{ibis.util.PoolInfo} utility
provides methods for finding out information about the nodes
involved in the closed-world run, such as:
\begin{itemize}
\item
the total number of hosts involved in the run.
\item
the rank number of the current host in the pool.
\item
the host names of the hosts involved in the run.
\item
the \texttt{InetAddress} of the hosts involved in the run.
\end{itemize}

\noindent
A \texttt{PoolInfo} instance is created with its 
static method \texttt{createPoolInfo()}.
It depends on the following system properties:
\begin{description}
\item[ibis.pool.total\_hosts]
This system property must be present for closed-world runs.
It indicates the total number of hosts involved in the run.
\item[ibis.pool.host\_names]
If present, this system property contains the list of host names
involved in the run.
If not present, \texttt{createPoolInfo} will a \texttt{PoolInfoClient}
that will collect this information during startup.
A \texttt{PoolInfoClient} uses a \texttt{PoolInfoServer} to collect the
required information.
This \texttt{PoolInfoServer} usually is started by the Ibis nameserver
(see Section \ref{The Ibis Nameserver}).

\item[ibis.pool.host\_number]
If present, this system property indicates the rank number of the
current host. If not present, the system will provide a rank number.
\end{description}

\mysubsubsection{Other utilities}

The \texttt{ibis.util.Stats} utility contains methods for computing
the mean and standard deviation of an array of numbers.
A timer utility is provided in \texttt{ibis.util.Timer}.
See the Ibis API for other utilities. Most of these are used in
Ibis implementations, but may have other uses.

\mysection{Compiling and Running an Ibis Application}

Before running an Ibis application it must be compiled.  Using
\emph{ant}, this is quite easy. Here is a \texttt{build.xml} file
for our example program:

\begin{quote}
\begin{verbatim}
<project
    name="client-server"
    default="build"
    basedir=".">

    <description>
    Ibis application build.
    </description>

    <property name="ibis"   location="/usr/local/ibis"/>
    <property name="build"  location="build"/>

    <import file="${ibis}/apps/ibis/build-ibis-app.xml"/>
</project>
\end{verbatim}
\end{quote}
The assumption here is that Ibis is installed in
\texttt{/usr/local/ibis}.
The line
\begin{quote}
\begin{verbatim}
    <property name="ibis"   location="/usr/local/ibis"/>
\end{verbatim}
\end{quote}
\noindent
may need to be modified to reflect the location of your Ibis
installation.

Now, invoking \emph{ant} compiles the application, leaving the class files
in a directory called \texttt{build}.

\mysubsection{The Ibis Nameserver}

Most Ibis implementations depend on a nameserver for providing
information about a particular run, such as finding Ibis instances
participating in the run, finding or registering receive ports, et cetera.
The Ibis nameserver collects this information for multiple Ibis
runs, even simultaneous ones. It does so by associating a user-supplied
identifier with each Ibis run. Each Ibis instance announces its
presence to the nameserver, using this identifier, so that the
nameserver can determine to which Ibis run this Ibis instance belongs.
The nameserver then notifies the other Ibis instances of this run that
a new instance has joined the run, including some identification of
this instance.

The Ibis nameserver is started with the \texttt{ibis\_nameserver} script which
lives in the Ibis \texttt{bin} directory. Before starting an Ibis application,
you need to have a nameserver running on a machine that is accessible
from all nodes participating in the Ibis run.
The nameserver expects the Ibis instances to connect to a
socket that it creates when it starts up.
The port number of this socket can be specified using a command line
option to the \texttt{ibis\_nameserver} script. This script recognizes
the following options:
\begin{description}
\item{-single}
specifies that the nameserver should only serve a single Ibis run
and then exit.
\item{-port \emph{portno}}
specifies the port number of the nameserver socket.
\item{-poolport \emph{poolportno}}
specifies the port number of the \texttt{PoolInfoServer} mentioned
in Section \ref{PoolInfo}.
\end{description}

\mysubsection{Running an Ibis Application}

An Ibis instance is started with the \texttt{run\_ibis} script which
lives in the Ibis \texttt{bin} directory.  This \texttt{run\_ibis}
script is called as follows:
\begin{center}
\texttt{run\_ibis} \emph{procno nprocs id port ns javaflags class ...}
\end{center}
The parameters are explained below:
\begin{description}
\item{\emph{procno}}
specifies the rank number of this Ibis instance within this run,
so its range is $0 ... \emph{nprocs}-1$.
\item{\emph{nprocs}}
specifies the total number of Ibis instances involved in this run.
\item{\emph{id}}
specifies the identifier used to identify the run to the nameserver.
\item{\emph{port}}
specifies the port of the Ibis nameserver, as described above.
\item{\emph{ns}}
specifies the hostname of the machine where the Ibis nameserver runs.
\item{\emph{javaflags}}
any flags that need to be passed on to java.
\item{\emph{class}}
specifies the application class name.
\item{...}
specifies the application parameters.
\end{description}

The \texttt{run\_ibis} script uses these parameters to set the following
system properties (see also Section \ref{PoolInfo}):
\begin{description}
\item{ibis.pool.host\_number}
the rank number of this Ibis instance.
\item{ibis.pool.total\_hosts}
the total number of Ibis instances.
\item{ibis.name\_server.key}
identifies the run to the nameserver.
\item{ibis.name\_server.port}
the nameserver port.
\item{ibis.name\_server.host}
the nameserver hostname.
\end{description}

In addition, the following system properties can be specified
(as \emph{javaflags}):
\begin{description}
\item{ibis.pool.cluster}
specifies a cluster name. If not specified,
``unknown'' is used.
See Section \ref{Satin job scheduling} for a possible need for cluster
names.
\item{ibis.pool.server.port}
specifies the port number on which the
\texttt{PoolInfoServer} is listening.
\end{description}

\remark{TODO: describe grun for wide-area runs}

\mysection{The Satin Divide-and-Conquer System}

Satin is a parallel programming environment for divide-and-conquer
parallelization, and (as a special case) worker-farmer parallelization.
Satin extends Java with two simple Cilk-like primitives for
divide-and-conquer programming.  The Satin byte-code rewriter and
runtime system cooperate to implement these primitives efficiently on
Ibis, using work stealing to distribute the jobs.

\mysubsection{Satin jobs}

To use Satin, the programmer must label one or more methods in his class
as Satin jobs. This is done by defining an interface that extends
the Satin interface \texttt{ibis.satin.Spawnable}.
A class that spawns work must extend the special class
\texttt{ibis.satin.SatinObject} and implement the above mentioned interface.
All methods that implement a method in such an
interface are Satin jobs. For example, given the following interface:

\begin{quote}
\begin{verbatim}
interface Searcher extends ibis.satin.Spawnable {
    public int search(int a[], int from, int to, int val);
}
\end{verbatim}
\end{quote}
\noindent
all methods that implement \texttt{Searcher.search()} will be Satin jobs.
In general such a marker interface may contain an arbitrary number
of methods.

When actually using Satin, invoking a Satin job puts this Satin job
on a job queue instead of invoking it directly.
Later on, the job will be executed either locally, or it will be
``stolen'' and executed by another processor.

The result of a Satin job can only be used after the invocation
of the \texttt{sync()} method, which lives in \texttt{ibis.satin.SatinObject}.
(A class that implements a job method must extend
\texttt{ibis.satin.SatinObject}.)
The \texttt{sync()}
method is guaranteed to only terminate after the earlier job
invocations have terminated.

Satin imposes one restriction on the type of parameters and return type
of a Satin job: they must be of a basic type or must be serializable.
A \texttt{SatinObject} is itself serializable, so all its subclasses
are serializable as well.
These two restrictions ensure that a Satin job can be stored and
moved from one processor to another (not while it is running, but before
it is started).

As an example, we could provide the following implementation of the
search method shown above:

\begin{quote}
\begin{verbatim}
class Search1Impl extends ibis.satin.SatinObject
              implements java.io.Serializable {
    public int search(int a[], int from, int to, int val) {
        for(int i = from; i < to; i++) {
            if (a[i] == val) return i;
        }
        return -1;
    }
}
\end{verbatim}
\end{quote}

Now, this method can be invoked as follows:

\begin{quote}
\begin{verbatim}
    Search1Impl s = new Search1Impl();
    int a[] = new int[200];

    // Do searches on two sub-domains of the array.
    int res1 = s.search(a, 0, 100, 0);
    int res2 = s.search(a, 100, 200, 0);

    // Wait for results of the two invocations above.
    s.sync();

    // Now compute an overall result.
    int res = (res1>0)?res1:res2;
\end{verbatim}
\end{quote}

As part of the Satin `contract', Satin is free to execute the two
invocations to \texttt{search()} in parallel.
In general, an arbitrary number of
invocations to Satin job methods may be done.

It is also allowed to invoke job methods from job methods, for example:

\begin{quote}
\begin{verbatim}
class Search2Impl extends ibis.satin.SatinObject
              implements java.io.Serializable {
    public int search(int a[], int from, int to, int val) {
        if (from == to) {
            return -1;
        }
        if (from+1 == to) {
            return (a[from] == val) ? from : -1;
        }
        int mid = (from+to)/2;
        int res1 = search(a, from, mid, val);
        int res2 = search(a, mid, to, val);
        sync();
        return (res1 > 0) ? res1 : res2;
    }
}
\end{verbatim}
\end{quote}
\noindent
Here the search is recursively divided into smaller problems until
a problem remains that is trivially handled.

\mysubsection{Exceptions and abort}

A Satin job may throw exceptions in the usual way. This can be used
to rapidly terminate a large set of jobs, for example because a search
result was found. In such cases it is often useful to terminate other
running jobs.  This can be done with the \texttt{abort()} method.  Satin has
its own exception type: \texttt{ibis.satin.Inlet}.  An \texttt{Inlet} is a
\texttt{Throwable} that inhibits the generation of a stack trace, which
is an expensive operation.

For example:

\begin{quote}
\begin{verbatim}
class SearchResultException extends ibis.satin.Inlet {
    int pos;
    SearchResultException(int p) { pos = p; }
}

class Search3Impl extends ibis.satin.SatinObject
              implements java.io.Serializable {
    public void search(int a[], int from, int to, int val) {
        if (from == to) {
            return;
        }
        if (from+1 == to) {
            if (a[from] == val) {
                throw new SearchResultException(from);
            }
            return;
        }
        int mid = (from+to)/2;
        search(a, from, mid, val);
        search(a, mid, to, val);
        sync();
    }
}
\end{verbatim}
\end{quote}

\noindent
Note that in this version the search method doesn't return a value,
since it will only terminate without throwing an exception if no
result is found.

At top level this exception must be caught, and the other search
jobs must be terminated. For example:

\begin{quote}
\begin{verbatim}
    Search3Impl s = new Search3Impl();
    int a[] = new int[200];
    int res = -1;

    try {
        // Do searches on two sub-domains of the array.
        s.search(a, 0, 100, 0);
        s.search(a, 100, 200, 0);

        // Wait for results of the two invocations above.
        s.sync();
    }
    catch(SearchResultException x) {
        res = x.pos;
        s.abort();
    }
\end{verbatim}
\end{quote}

\mysubsection{Satin job scheduling}

Satin offers a choice of three different job scheduling strategies:
\begin{description}
\item[Random work-stealing]
when using random work-stealing, when looking for work, each Satin
first examines its own job queue. When this job queue is empty,
it randomly selects another Satin and takes the first job on its job queue.
If that job queue is empty, it randomly selects another Satin, et cetera,
et cetera.  This strategy is the default, and has in the past been proven
to be optimal, although that might seem counter-intuitive.

\item[Cluster-aware random work-stealing]
the word ``cluster'' refers to a group of computers that are connected
to each other by means of a fast local network.
In turn, clusters can be connected to each other, but usually the
network between clusters is much slower, and/or has a much higher latency.
The cluster-aware random work-stealing strategy
is very similar to random work-stealing, except that
each participant first tries to steal jobs from other participants in its
own cluster (thus using the fast local network).
It will only go to participants from other clusters if no participant on the
same cluster has work.
To determine to which cluster a participant belongs, the cluster name
is used.
As described in Section \ref{Running an Ibis Application},
the \emph{ibis.pool.cluster} system property can be used to
specify a cluster name to the Ibis instance.

\item[Master-worker]
this strategy is suitable for applications where all Satin jobs are
generated on a single participant, the ``master''. All other participants
are ``workers'', they obtain jobs from the master and execute them.
\end{description}

Making sure that all participants always can find work to do may need
some tuning. Jobs must not be too small, because otherwise the mechanism
for obtaining jobs, which may involve network traffic, is too expensive.
On the other hand, there must be enough jobs to keep everybody busy.
The \texttt{SatinObject} class has a boolean method \texttt{needMoreJobs()},
which indicates whether it would be useful to generate more jobs.

\mysubsection{Other SatinObject methods}

The \texttt{pause()} method pauses Satin operation. When the application
contains a large sequential part, this method can be called to temporarily
pause Satin's internal load distribution strategies to avoid communication
overhead during the execution of sequential code.
To resume Satin operation, the \texttt{resume()} method must be used.

\mysubsection{Satin program arguments}

The Satin system accepts the following arguments. They are
filtered out from the program arguments, leaving the application's
arguments:
\begin{description}
\item[-satin-closed]
Only use the initial set of hosts for the computation; do not allow
further hosts to join the computation later on.
\item[-satin-stats]
Display some statistics at the end of the Satin run. This is the default.
\item[-satin-detailed-stats]
Display detailed statistics for every member at the end of the Satin run.
\item[-satin-no-stats]
Don't display statistics at the end of the Satin run.
\item[-satin-panda]
Use the Panda version of Ibis.
\item[-satin-mpi]
Use the MPI version of Ibis.
\item[-satin-net]
Use NetIbis.
\item[-satin-nio]
Use NIO Ibis.
\item[-satin-tcp]
Use the TCP version of Ibis.
\item[-satin-ibis]
Use Ibis serialization. When no serialization is specified,
the object serialization used is determined by Ibis.
\item[-satin-sun]
Use Sun serialization.
\item[-satin-upcalls]
Use upcalls for receiving messages. This is the default.
\item[-satin-no-upcalls]
Use explicit receipt for receiving messages.
\item[-satin-upcall-polling]
Use upcalls for receiving messages, but Satin must explicitly poll to get
upcalls.
\item[-satin-alg \emph{algorithm}]
Specify the load-balancing algorithm to use. The possible values for
\emph{algorithm} are: RS for random work-stealing, CRS for cluster-aware
random-work stealing, and MW for master-worker
\end{description}

The following flags are for tuning by the developers of Satin,
and should not be used unless you really know what you are doing.
\begin{description}
\item[-satin-queue-size \emph{integer}]
The maximum desirable job queue size. If the current work queue 
has more than this number of jobs, Satin indicates that 
it does not need more jobs (as can be asked though the
needMoreJobs() method).
\end{description}

\mysubsection{The Satin Tuple Space}

The \texttt{ibis.satin.SatinTupleSpace} class implements a global tuple
space.  A tuple consists of a key (a \texttt{String}) and its associated
data (a serializable object). Here, global means that the tuple space is
available on all members. The \texttt{SatinTupleSpace} has the following
methods:

\begin{quote}
\begin{verbatim}
static void add(String key, Serializable data);
static Serializable get(String key);
static Serializable peek(String key);
static void remove(String key);
\end{verbatim}
\end{quote}

The \texttt{add()} method adds a tuple to the tuple space, associating the
specified key with the specified data.
The \texttt{get()} method obtains the data associated with the specified key.
It blocks until there is actually data associated with the key.
The \texttt{peek()} method, in contrast, does not block, but returns
\texttt{null} instead.
The \texttt{remove()} method removes the tuple that has the specified key.

All members can add tuples, and no global ordering is imposed on the
additions, unless the system property
\texttt{satin.tuplespace.ordered} is defined and represents the
boolean value \texttt{true}. In this case, a global ordering is imposed.

The Satin tuple space supports \emph{active tuples}.
The \texttt{ibis.satin.ActiveTuple} interface serves
as a marker for active tuples. It contains a single method:

\begin{quote}
\begin{verbatim}
void handleTuple(String key);
\end{verbatim}
\end{quote}

When an active tuple is added (as data) to the tuple space,
its \texttt{handleTuple()} method will be invoked on all members.
This can be used, for instance, for modifications of data that
is replicated on all members.

A serious limitation of the current tuple space implementation is that
it is only supported for closed-world runs.

\mysubsection{Compiling and running a Satin program}

Before running a Satin application it must be compiled.
Using \emph{ant}, this is quite easy. Here is a build.xml file for
our example program:

\begin{quote}
\begin{verbatim}
<project
    name="Search"
    default="build"
    basedir=".">

    <description>
    Satin application build.
    </description>

    <property name="ibis"   location="/usr/local/ibis"/>
    <property name="build"  location="build"/>

    <import file="${ibis}/apps/satin/build-satin-app.xml"/>
</project>
\end{verbatim}
\end{quote}
Note that the assumption here is that Ibis is installed in
\texttt{/usr/local/ibis}.

Invoking \emph{ant clean compile} compiles a sequential version
of the application, 
leaving the class files in a directory called \texttt{build}.

Invoking \emph{ant clean build} compiles the application for parallel
runs.

Running a Satin program is very much like running an Ibis application.
See Section \ref{Compiling and Running an Ibis Application} for details.

\mysection{The GMI System}

\remark{TODO.}

\mysection{Ibis RMI}

\remark{TODO: limitations/restrictions.}

\mysection{Further Reading}

The Ibis web page
{\html {\htmladdnormallink{http://www.cs.vu.nl/ibis/publications.html} {http://www.cs.vu.nl/ibis/publications.html}}}
{\latex {http://www.cs.vu.nl/ibis/publications.html}}
contains links to various Ibis papers.

The \emph{docs/api} subdirectory of the Ibis installation provides
documentation for each class and method in the Ibis API (point your favorite
HTML viewer to docs/api/index.html file of the Ibis installation).
The Ibis API is also available
\html{\htmladdnormallink{on-line}{http://www.cs.vu.nl/ibis/api/index.html}.}
\latex{on-line at http://www.cs.vu.nl/ibis/api/index.html.}

\end{document}
