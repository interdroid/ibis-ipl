\documentclass[10pt]{article}

\usepackage{html}

\newcommand{\mysection}[1]{\section{#1}\label{#1}}
\newcommand{\mysubsection}[1]{\subsection{#1}\label{#1}}
\newcommand{\mysubsubsection}[1]{\subsubsection{#1}\label{#1}}

\begin{document}

\title{
{\html {\htmladdnormallink{Ibis} {http://www.cs.vu.nl/ibis/}}}
{\latex {Ibis}}
Programmer's Manual}

\maketitle

\section{Introduction}

This manual describes how to write and run Ibis applications.
\begin{htmlonly}
It is also available in
\htmladdnormallink{postscript}{http://www.cs.vu.nl/ibis/progman.ps.gz}.
\end{htmlonly}
Ibis is a Java-centric grid programming environment.
It is described in several publications (see Section \ref{Further Reading}).
Rather than giving a detailed overview of what each class and method does,
the aim of this document is to describe how to actually use these classes
and methods.
The \emph{docs/api} subdirectory of the Ibis installation provides
documentation for each class and method.
Fragments of an actual Ibis application will be used for illustration purposes.
Section \ref{An Ibis Application} will discuss a typical Ibis application,
with subsections on each phase of the program.
Section \ref{Compiling and Running an Ibis Application} will discuss how to
actually compile and run this program.

We also built several systems on top of Ibis.
Section \ref{The Satin Divide-and-Conquer System}
gives an overview of the Satin divide-and-conquer
system, and Section \ref{The GMI System} discusses GMI
(Group Method Invocation),
a flexible group communication system.
We also built a (not quite complete) RMI (Remote Method Invocation)
implementation on top of Ibis. RMI documentation can be found on-line at
{\html {\htmladdnormallink{http://java.sun.com}{http://java.sun.com}}}
{\latex {http://java.sun.com}}.
Section \ref{Ibis RMI} briefly discusses the Ibis RMI implementation.

\mysection{Some Ibis concepts}

\mysubsection{The Ibis Portability Layer}

The top layer of the Ibis system consists of the Ibis Portability Layer(IPL).
The IPL consists of a set of Java interfaces that define how an Ibis application
can make use of the Ibis components.
The Ibis application does not need to know which specific Ibis implementations are
available.
It just specifies some properties that it requires, and the Ibis system
selects the best available Ibis implementation that meets these requirements.
 
\mysubsection{An Ibis Instance}

A loaded Ibis implementation is called an \emph{Ibis instantiation}, or 
\emph{Ibis instance}.
An Ibis instance is identified by a so-called
\emph{Ibis identifier}.
An application can find out which Ibis instances are present in the run
by supplying a so-called \emph{ResizeHandler}.
This ResizeHandler is an object with, among others, a \emph{join} method
which gets called by the Ibis system when a new Ibis instance joins the
run.
The Ibis identifier of this new Ibis is a parameter to the join method.

\mysubsection{Send Ports and Receive Ports}

The IPL provides communication primitives using send ports and receive ports.
The Ibis application creates the send ports and receive ports, and sets up
connections between them, using primitives provided by the IPL.
A connection is \emph{unidirectional}, from a send port to one or more
receive ports.
To send a message, the Ibis application has to obtain a
write message from a send port, put data in this write message using
the methods provided by the write message, and \emph{finish} the
message.
To receive a message, the IPL provides two mechanisms:
\begin{description}
\item[explicit receipt]
when a receive port is configured for explicit receipt, a message can be
received with the receive port's blocking \emph{receive} primitive.
This method returns a \emph{read message} object. from which data can
be extracted using its read methods.
\item[upcalls]
when a receive port is configured for upcalls, the Ibis application provides
an \emph{upcall} method, which is to be called when a message arrives.
The upcall provides the message received as a parameter.
The message contents will be lost when the upcall returns, so the data
in the message must be read in the upcall.
\end{description}

\mysubsection{Port Types}

Send and receive ports are \emph{typed} by means of a \emph{port type}.
A port type is defined and configured with properties.
Only ports of the same type can be connected.
Port type properties that can be configured are, for instance, the
serialization method used, reliability, wether a send port can connect
to more than one receive port, wether more than one send port can connect
to a single receive port, et cetera.

\mysubsection{Serialization}

Serialization is a mechanism for converting Java objects into some
format that can be stored or transferred.
Java has input (java.io.ObjectInputStream) and output
(java.io.ObjectOutputStream) streams for reading and writing objects.
In Ibis, we call this mechanism \emph{Sun serialization}.
Ibis also has its own mechanism, which is completely compatible
(with regard to its interface) with Sun serialization, but more efficient.
We call this mechanism \emph{Ibis serialization}.

Sometimes, object serialization is not needed. For that case, two simpler
serialization mechanisms are available: \emph{data serialization} which
allows for sending/receiving data of basic types and arrays of basic types
(similar to java.io.DataInputStream/java.io.DataOutputStream), and
\emph{byte serialization} which only allows sending/receiving bytes
and arrays of bytes.

\mysection{An Ibis Application}

An Ibis application consists of several parts:
\begin{itemize}
\item
Creating an Ibis in each instance of the application.
An Ibis application runs on multiple hosts. On each of these hosts, an Ibis
must be created.
\item
Setting up communication. A communication connection consists of a
\emph{send port}, through which messages can be sent, and one or
more \emph{receive ports},
through which messages can be received, and a connection between them.
\item
Actually communicating. A send port is used to create a 
\emph{write message}, which is sent to the receive ports that this send port
is connected to.
\item
Finishing up. Connections must be closed, and each Ibis instance must
be ended.
\end{itemize}

The next few subsections will discuss each of these steps in turn,
illustrating them with parts of an RPC-style Ibis application.
This application will have a client and a server. As this is a toy
application, the server will have to compute the length of a string.
The client will send the string, and receive the result.
The server will have to do some other work as well, just to make
things a little more interesting.

\subsection{Program Preamble}

All Ibis applications import classes from the IPL (Ibis
Portability Layer) package, which lives in
\verb+ibis.ipl+.
So, the preamble of your program could just consist of one line:
\begin{quote}
\begin{verbatim}
import ibis.ipl.*;
\end{verbatim}
\end{quote}
It might also exist of an import of each class that is used,
but this might easily result in a list of 10 or more \verb+import+s.

\mysubsection{Creating an Ibis Instance}

All instances of a program that want to participate in an Ibis run
must create an Ibis instance.
To create an Ibis instance, the \verb+createIbis+ method of the
\verb+ibis.ipl.Ibis+ class must be used.
The specification of this method is:
\begin{quote}
\begin{verbatim}
Ibis createIbis(StaticProperties props,
                ResizeHandler h)
        throws IbisException;
\end{verbatim}
\end{quote}
There may be several Ibis implementations available, and
the system selects the best one for you, based on some
user-specified requirements.
These requirements tell the system what features must be supported
by the selected Ibis.
They are summarized in an object of the
\verb+ibis.ipl.StaticProperties+ class.
For example, below is a snippet from the RPC example:
\begin{quote}
\begin{verbatim}
StaticProperties props = new StaticProperties();
props.add("communication", "OneToOne, Reliable, " + 
                           "AutoUpcalls, ExplicitReceipt");
props.add("serialization", "object");
props.add("worldmodel", "closed");
\end{verbatim}
\end{quote}
This states that the selected Ibis must support reliable one-to-one
communication, must support upcalls at the receiver side without the
receiver having to poll for messages, and must also support explicit
receipt of messages at the receiver side.
(We want upcalls so that the server can do other work, and we want
explicit receipt for the client side).
In addition, the selected Ibis must support some form of object
serialization (a string must be sent),
and must support the ``closed'' worldmodel, which means
that all participating Ibises join at the start of the run, and a
synchronization takes place before \verb+createIbis+ returns.
(in the example we have a client and a server).

A complete list of property values is given below.
The possible property values of the ``communication'' property are
(capitals are not significant):
\begin{description}
\item[OneToOne]
One-to-one (unicast) communication is supported (if an Ibis does not support
this, you may wonder what it \emph{does} support).
\item[OneToMany]
one-to-many (multicast) communication is supported.
(in Ibis terms: a sendport
may connect to multiple receiveports).
\item[ManyToOne]
many-to-one communication is supported (in Ibis terms: multiple
sendports may connect to a single receiveport).
\item[FifoOrdered]
messages from a send port are delivered to the receive ports it is
connected to in the order in which they were sent.
\item[Sequenced]
all messages originating from any send port of a specific port type have
a sequence number. This allows the application to do its own sequencing.
\item[Reliable]
reliable communication is supported, that is,
a reliable communication protocol is used.
When not specified, an Ibis may be chosen that does not explicitly
support reliable communication.
\item[AutoUpcalls]
upcalls are supported and polling for them is not required.
This means that when the user creates a receiveport with an upcall
handler installed, when a message arrives at that receive port, 
this upcall handler is invoked automatically.
\item[PollUpcalls]
upcalls are supported but polling for them is required. When an
Ibis implementation claims that it has this, it may also do
AutoUpcalls but polling does no harm. When an application asks for
this (and not AutoUpcalls), it must poll.
\item[ExplicitReceipt]
explicit receive is supported.
This is the alternative way to upcalls for receiving messages.
\item[ConnectionDowncalls]
connection downcalls are supported. This means that the user can
invoke methods to see which connections were lost or created.
\item[ConnectionUpcalls]
connection upcalls are supported. This means that an upcall
handler can be installed that is invoked whenever a new connection arrives
or a connection is lost.
\end{description}

The possible ``serialization'' properties are:
\begin{description}
\item[Byte]
readByte/writeByte and readArray/writeArray(byte[]) are supported.
\item[Data]
read/write and readArray/writeArray of basic types are supported.
\item[Object]
Some sort of object serialization is supported. An Ibis implementation
will, of course, specify what kind of object serialization it supports.
The ``Object'' property allows a user to just ask for object
serialization, and not care if it is Ibis or Sun serialization.
\item[Ibis]
Ibis serialization is supported.
This is the fastest object serialization supported in Ibis. Its drawback
is that it requires identical Java implementations on sender and
receiver side, and does not support
non-symmetrical writeObject/readObject methods (where readObject does not
read everything that writeObject writes).
\item[Sun]
Sun serialization (through java.io.ObjectOutputStream/InputStream) is
supported.
\end{description}

The possible ``worldmodel'' properties are:
\begin{description}
\item[Open]
this means that Ibises can join the run at any time during the run.
\item[Closed]
this means that the Ibises that can join the run are determined
at the start of the run.
\end{description}

If a specific implementation of Ibis is required, that can be delt with too.
There is a property called ``name'', which can be used to supply a nickname
for the Ibis implementation that is required.
The currently known nicknames are:
\begin{description}
\item[tcp]
This is an Ibis implementation on top of TCP sockets, and currently is
probably the most stable Ibis around, and it supports almost all properties.
\item[panda]
This is a messagePassing Ibis implementation on top of the Panda
communication layer. It only supports the ``closed'' worldmodel,
but on our system it gives much higher throughput and lower latencies
because it runs on Myrinet instead of our (100Mbitps) Ethernet on which
the tcp version runs.
\item[net]
This is the most flexible Ibis implementation, but still in an experimental
stage.
\item[nio]
This is a (still experimental) Ibis implementation on top of Java NIO.
\item[mpi]
This is the messagePassing Ibis implementation but on top of MPI instead
of Panda. This too is an experimental version.
\end{description}

A user running an Ibis application can override a property, or make it
more specific. This is done by means of Java system properties, which
in many Java implementations can be set by means of a command line option,
for instance -D\emph{property}=\emph{value}.
The system property name is that of the Ibis static property, prefixed
with ``\verb+ibis.+''.
So, adding \verb+-Dibis.serialization=ibis+ to the command line will
cause \verb+createIbis+ to look for an Ibis that supports ibis serialization
instead of any object serialization.

This completes the description of the first parameter
of \verb+createIbis+. The second parameter specifies an upcall handler
with \verb+join+ and \verb+leave+ upcalls that get called when an Ibis
joins or leaves the run.
In our RPC example, we will not use this, so we specify \verb+null+
instead.
However, when such a \verb+ResizeHandler+ is used, its \verb+join+
upcall is called for every Ibis that joins the run, including the
Ibis being created.
To prevent upcalls from occuring before the
creation of this Ibis is completed, these upcalls must be explicitly
enabled by invoking the \verb+openWorld+ method of the Ibis just
created. In addition, the \verb+openWorld+ method blocks until the
\verb+join+ upcall for this Ibis has been invoked.
Knowing which Ibises have joined the run, and how many there are, may
be useful in dividing the work. See also section \ref{Which Instance Does What?}.

Now back to our example. 
With the \verb+props+ as defined above, we create an Ibis as follows:
\begin{quote}
\begin{verbatim}
try {
    Ibis ibis = createIbis(props, null);
} catch(NoMatchingIbisException e) {
    System.err.println("Could not find a matching Ibis");
    ...
}
\end{verbatim}
\end{quote}
Note that the properties can be so specific that no matching Ibis
can be found. Therefore, \verb+createIbis+ may throw an exception
indicating this.

\subsection{Setting up Communication}

Setting up communication consists of several steps:
\begin{itemize}
\item
create a port type;
\item
create a send and a receive port;
\item
setting up connections between them.
\end{itemize}

The next few subsections discuss each of these steps in turn.

\subsubsection{Creating a Port Type}

The next step is to create a \emph{port type}, from which
send and receive ports can be created. A port type is an object
of type \verb+ibis.ipl.PortType+.
Within an Ibis instance,
multiple port types, with different properties, can be created.
The properties of a port type are, like the required properties
of an Ibis, specified by a \verb+StaticProperties+ object.
A port type is identified by its name, together with these properties.
The \verb+Ibis+ class contains a method to create a port type,
specified as follows:
\begin{quote}
\begin{verbatim}
PortType createPortType(String name,
                        StaticProperties portprops)
        throws IbisException, java.io.IOException;
\end{verbatim}
\end{quote}

For our RPC example program, we would create a port type with properties
as discussed in Section \ref{Creating an Ibis Instance}:

\begin{quote}
\begin{verbatim}
StaticProperties portprops = new StaticProperties();
portprops.add("communication",
              "OneToOne, Reliable, " + 
                  "AutoUpcalls, ExplicitReceipt");
portprops.add("serialization", "object");
PortType porttype = null;
try {
    porttype = ibis.createPortType("RPC port", portprops);
} catch(Exception e) {
    ...
}
\end{verbatim}
\end{quote}

In general, the port properties should be a subset of the properties
specified when creating the Ibis instance. If a property is specified
that was not specified when creating the Ibis instance, this could
result in an \verb+IbisException+.
An \verb+IbisException+ could also result when the same name is
already used for a port type with different properties.
Port types are registered with an internal or external name server
(this will be discussed in Section \ref{Compiling and Running an Ibis Application}).
If communication with this name server fails, a
\verb+java.io.IOException+ is thrown.

\mysubsubsection{Which Instance Does What?}

Up until now, we have discussed only matters that all instances of
the Ibis application should do, but now, things become different.
One instance of the application may want to send messages, while
another instance may want to receive them.
It may not even be clear which instance is going to do what.
This can of course be solved with program parameters, but Ibis
also provides a so-called registry (of type
\verb+ibis.ipl.Registry+), which is obtained through the
\verb+ibis.regstry+ method.
Ibis also provides the \verb+ibis.ipl.IbisIdentifier+ class.
the \verb+ibis.ipl.Ibis.identifier+ method returns such an
Ibis identifier, which identifies this specific Ibis instance.
Now it is possible to decide, in the RPC example, who is going
to be the server by means of an ``election'': the Ibis registry
provides a method \verb+elect+ which (globally) selects one of
a number of invokers.
For our RPC example this would go as follows:

\begin{quote}
\begin{verbatim}
IbisIdentifier me = ibis.identifier();
Registry registry = ibis.registry();
IbisIdentifier server = (IbisIdentifier)
                          registry.elect("Server", me);
boolean i_am_server = server.equals(me);
\end{verbatim}
\end{quote}

It could also be that the client and the server are separate programs.

The \verb+ResizeHandler+, as discussed in Section
\ref{Creating an Ibis Instance}, can be used to keep track of the number
of Ibis instances currently involved in the run.

\subsubsection{Creating Send and Receive Ports}

The \verb+PortType+ class contains several variants of a method
\verb+createSendPort+ that creates a send port (of type
\verb+ibis.ipl.SendPort+) and
also several variants of a method \verb+createReceivePort+ that
creates a receive port (of type \verb+ibis.ipl.ReceivePort+),
See the API for an exhaustive list of variants.

In Ibis, receive ports usually have specific names, so that
a send port can set up a connection to a receive port. In contrast,
send ports usually are anonymous, because a receive port cannot
initiate a connection.

For our RPC example, the server will have to create a receive port
to receive a request and a send port to send an answer.
The server is not allowed to block waiting for a request, so it will
want a receive port that enables upcalls.
To do that, the server must first define a class that implements
the \verb+ibis.ipl.Upcall+ interface. This interface contains one
method:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws java.io.IOException;
\end{verbatim}
\end{quote}

We will go into the details of a \verb+ReadMessage+ in Section
\ref{Communicating}. For now, we will assume that there is a
class \verb+RPC_Upcall+ that implements this interface, and
a field \verb+rpc_upcall+ of this type.

\begin{quote}
\begin{verbatim}
try {
    SendPort server_sender = porttype.createSendPort();
    ReceivePort server_receiver =
        porttype.createReceivePort("server", rpc_upcall);
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

The client will have to create a send port
to send a request and a receive port to receive an answer.
The client is allowed to block waiting for an answer, so it will
want a receive port that enables explicit receipt.
So, the client will create an anonymous server port, and a named
receive port that enables explicit receipt:

\begin{quote}
\begin{verbatim}
try {
    SendPort client_sender = porttype.createSendPort();
    ReceivePort client_receiver =
        porttype.createReceivePort("client");
} catch(java.io.IOException e) {
    ....
}
\end{verbatim}
\end{quote}

When a receive port is created, it will not immediately accept connections.
This must be explicitly enabled by
invoking the \verb+enableConnections+ method. So, the creator of
the receive port can determine when he is ready to accept connections.
If the receive port is configured for upcalls, these must
explicitly be enabled by invoking the \verb+enableUpcalls+ method.

\subsubsection{Setting Up a Connection}

Now that we have send ports and receive ports, it is time to set up
connections between them.
A connection is initiated by the \verb+connect+ method of
\verb+ibis.ipl.SendPort+.
Here is its specification:

\begin{quote}
\begin{verbatim}
void connect (ReceivePortIdentifier r) throws IOException;
\end{verbatim}
\end{quote}

This version blocks until an accept or deny is received, and throws
an \verb+IOException+ when the connection could not be established.
There also is a \verb+connect+ version with a time-out.

So, we need a \verb+ibis.ipl.ReceivePortIdentifier+ to set up the
connection.
This identifier can be obtained through the Ibis registry, by
means of the \verb+lookup+ method, which has the following specification:

\begin{quote}
\begin{verbatim}
ReceivePortIdentifier lookup(String name)
        throws IOException;
\end{verbatim}
\end{quote}

This method blocks until a receive port with the specified name is found.
Our RPC server would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier clnt = registry.lookup("client");
    server_sender.connect(clnt);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

Our RPC client would set up the following connection:

\begin{quote}
\begin{verbatim}
try {
    ReceivePortIdentifier srvr = registry.lookup("server");
    client_sender.connect(srvr);
} catch(IOException e) {
    ...
}
\end{verbatim}
\end{quote}

This completes the connection setup.

Note that a send port can set up connections to more than one
receive port (if the port type supports the \verb+OneToMany+
communication property). Also, multiple send ports can set up
connections to the same receive port (if the port type supports
the \verb+ManyToOne+ communication property).

\subsection{Connection upcalls, connection downcalls}
Sometimes it is useful for an application to know which send ports
are connected to a receive port, and vice versa.
TODO. connection upcalls/downcalls.


\mysubsection{Communicating}

As the reader may have noticed by now, communication in Ibis
consists of messages, sent from a send port, and received at a
receive port. When a sender wants to send a message, it will first
have to obtain one from the send port. Such a message is of
type \verb+ibis.ipl.WriteMessage+ and is obtained by means of
the \verb+newMessage+ method of \verb+SendPort+, which is specified
as follows:

\begin{quote}
\begin{verbatim}
WriteMessage newMessage() throws IOException;
\end{verbatim}
\end{quote}

For a given send port, only one message can be alive at any time.
When a new message is requested while a message is alive, the request
is blocked until the live message is finished.

Once a write message is obtained, data can be written to it.
A write message has various methods for the different types of
data that can be written to it. For instance, the
\verb+writeInt+ method can be used to write an integer value,
and the \verb+writeObject+ method can be used to write an object.
The kind of data that can be written to the message depends on the
serialization property specified when the port type was created.
The most general form is object serialization, which supports 
all write methods in a write message.
The \verb+data+ serialization property does not allow use of the
\verb+writeObject+ method, but does allow the use of all other write
methods. The \verb+byte+ serialization property only allows use
of the \verb+writeByte+ method and the \verb+writeArray(byte[])+
method.

Once there is a considerable amount of data in the message, Ibis
can be given a hint to start sending, using the \verb+send()+
method. This hint is not needed, however. When the message is
complete, the message can be sent out by invoking the
\verb+finish()+ method.

Our client in the RPC example could have the following:
\begin{quote}
\begin{verbatim}
int obtainLength(String s) throws IOException {
    WriteMessage w = client_sender.newMessage();
    w.writeObject(s);
    w.finish();
    ...
\end{verbatim}
\end{quote}

At the receiving side, a message can be received in two ways,
depending on how the receive port was created: either by means of an
upcall, or by means of an explicit receive. For each write method
in a write message, there is a corresponding read method in
a read message. For a given receive port, only one message can
be alive at any time. A read message is alive until it is
finished (by a \verb+finish+ call), or the upcall returns.

Now, let us present some more code of our RPC example, this time
from the server:

\begin{quote}
\begin{verbatim}
void upcall(ReadMessage m) throws IOException {
    String s = (String) m.readObject();
    int len = s.length;
    m.finish();
    WriteMessage w = server_sender.newMessage();
    w.writeInt(len);
    w.finish();
}
\end{verbatim}
\end{quote}

Note that the read message is finished before replying to the
request. To prevent deadlocks, upcalls are not allowed to block in
condition sychronization or network access as long as the message
is active. This means that a thread is not allowed to write as long
as a read message is active, and a thread is not allowed to wait for
some condition (call \verb+Thread.wait()+).

Now, we can also finish the \verb+obtainLength+ method of the client:
\begin{quote}
\begin{verbatim}
    ...
    ReadMessage r = client_receiver.receive();
    int len = r.readInt();
    r.finish();
    return len;
}
\end{verbatim}
\end{quote}

\subsection{Finishing up}

Closing of a connection is initiated by closing a send port
(by means of the \verb+close+) method. The \verb+ReceivePort+
class also has a \verb+close+ method, but this method blocks
until all send ports that have a connection to it are closed.
So, send ports have to be closed first.

Our RPC client will do the following:

\begin{quote}
\begin{verbatim}
client_sender.close();
client_receiver.close();
\end{verbatim}
\end{quote}
and the code of the server should be clear by now.

Ibis itself must also be ended. Both our client and our server
should invoke the \verb+Ibis.end+ method:
\begin{quote}
\begin{verbatim}
ibis.end();
\end{verbatim}
\end{quote}

As of Java 1.3, it is also possible to add a so-called shutdown hook.
This could be done right after the Ibis instance is created:
\begin{quote}
\begin{verbatim}
Runtime.getRuntime().addShutdownHook(new Thread() {
    public void run() {
        try {
            ibis.end();
        } catch (IOException e) {
        }
    }
});
\end{verbatim}
\end{quote}

This shutdown hook gets invoked when the program terminates.

\mysubsection{Ibis utilities}

The \verb+ibis.util+ package contains several utilities that may be
useful for Ibis applications. We will discuss some of them here.

\mysubsubsection{PoolInfo}

The \verb+ibis.util.PoolInfo+ class is a very useful utility for
closed-world applications.
It provides methods for finding out information about the nodes
involved in the closed-world run, such as:
\begin{itemize}
\item
the total number of hosts involved in the run.
\item
the rank number of the current host in the pool.
\item
the host names of the hosts involved in the run.
\item
the \verb+InetAddress+ of the hosts involved in the run.
\end{itemize}

The preferred way of creating a \verb+PoolInfo+ is by means of the
static method \verb+createPoolInfo+.
It depends on the following system properties:
\begin{description}
\item{\verb+ibis.pool.total_hosts+}
\item{\verb+ibis.pool.host_names+}
\item{\verb+ibis.pool.host_number+}
\end{description}

TODO

\mysubsubsection{PoolInfoClient}

The \verb+ibis.util.PoolInfoClient+ is a subclass of
\verb+ibis.util.PoolInfo+.  ...TODO...


\mysection{Compiling and Running an Ibis Application}

Before running an Ibis application it must be compiled.
Using \emph{ant}, this is quite easy. Here is a build.xml file for
our example program:

\begin{quote}
\begin{verbatim}
<project
    name="client-server"
    default="build"
    basedir=".">

    <description>
    Ibis application build.
    </description>

    <property name="ibis"   location="/usr/local/ibis"/>
    <property name="build"  location="build"/>

    <import file="${ibis}/apps/ibis/build-ibis-app.xml"/>
</project>
\end{verbatim}
\end{quote}
Note that the assumption here is that Ibis is installed in
\verb+/usr/local/ibis+.

Now, invoking \emph{ant} compiles the application, leaving the class files
in a directory called \verb+build+.

\mysubsection{The Ibis Nameserver}

Most Ibis implementations depend on a name server.
The name server ...TODO...

\mysection{The Satin Divide-and-Conquer System}

TODO.

\mysection{The GMI System}

TODO.

\mysection{Ibis RMI}

TODO: limitations/restrictions.

\mysection{Further Reading}

\end{document}
