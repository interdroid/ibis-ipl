Legend:
- = current
+ = done since last core meeting (or not removed ...)
* = new/changed since last core meeting
? = suggestion, still needs to be discussed

##### Ibis 2.0 ####

IPL:
- check properties for unknown properties
+ MessageUpcall.upcall: may also cause ClassNotFoundException? --Ceriel
  (Done Ceriel)

management:
+ add basic network usage statistics to Ibis. (Which ones? --Ceriel)
  (Done Ceriel)

ibis registry:
+ check if all Ibisses in a pool are of the same implementation, version, etc. (Done, Niels)
+ rename registry.waitForAll() to waitUntilPoolClosed() (Done, Niels)
- make registry implement Management class
+ add some more pool related prints to the registry server (Done, Niels)
- add precise definition of "closed world pool" somewhere

applications:
- remove old-n-useless applications (if any)

packaging/distribution:
- split up ibis in multiple separate subprojects:
	+ ipl
	+ ipl applications (Done Ceriel)
	+ util
	+ server (Done Niels)
	+ io (Done Ceriel)
	+ compile (Done Ceriel)
	foreach(programming model) {
		+ programming model
		- programming model applications
	} (Done programming models --Ceriel)
	- standalone applications (DFA, SAT4Satin, Barnes)	
	- make external dir in every subproject so that each subproject
	  is self-contained.
- update/rewrite programmers manuals
- while(true) {fix eclipse warnings}
+ clean up doc building scripts (Done Ceriel)

website:
- update "ibis" overview picture with new/changed implementations
- add overview section
- update/create each subproject page
- add javadoc top-button where applicable

##### Ibis 2.X ####

Ibis:
- while(true) {fix eclipse warnings}
- more efficient clone? Maybe generate code that clones without using 
  serialization. Could be done for objects passed as a param
  to a spawn, for instance. If code is not there, fall back to current impl.

ibis registry:
- gossip Registry

implementations:
- fix/improve performance of MpiIbis
- Implement multi Ibis.
- Implement LRMC Ibis
- benchmark serialisation. Especially focus on the performance gain when
  rewriting the classlibs. This functionality is rather tricky, if it doesn't
  gain us anything anymore, we might as well remove it.

applications:
- check results of the different barnes versions

deployment/testing/benchmarking:
- implement "Ibis deployment application" using the GAT
- implement GUI/Scripting/Shell/Commandline interface on Ibis deployment app
- reimplement codmon on-top-of the GAT
- change codmon performance measurements to "sane" benchmarks


satin:
- measure cost of sucessful and unsucessful steal attempts seperately
- add semantic analysis to the compiler
- forgotten sync statements
- make return / throw an implicit sync again?
- add comments to abort / inlet machinism
- shutdownhook -> System.exit
- satinc does not understand monitorenter/monitor exit instructions (othello)
- detection of what is an inlet: now, if the invocation is inside a try-catch
  it is assumed to be an inlet. Is this OK? (Maybe change to checked Exception)
- ant test should also run satin apps sequentially
  (It does, does'nt it? (Ceriel) No, it does not run non-rewritten code)
- investigate invocation record cache again. It makes a huge difference for
  performance of small tasks. The fact that it does not seem to work is an
  indication that there is a bug somewhere: someone touches an invocation
  record after it has been cleared!
- update docs: don't call System.exit at the end of main(). Satin should be
  allowed to terminate normally. If main() calls exit, fault-tolerance will
  think that the master died, and restart the master on another node!
  Or: could the Satin rewriter somehow deal with this? Or: shutdown hook?
- Bug: If the user "main" exits before all satin instances are fully
  initialized satin doesn't exit properly.

satin-so:
- count all messages+sizes for the total messages/data sent statistics --Rob
- do not send the same object (and the same version) twice.
  This can happen if it is both broadcast, and pulled at the same time --Rob
- Allow shared objects to be passed anywhere in the parameter data 
  structures. Now only directly as a param. Maybe use stubs instead of
  direct access? This would make the implementation much easier --Rob
- message combining does not help because:  (--Rob)
    - object-id is sent every time (long string)
    - combiner is synchronized
    - overhead of method calls, serialization
