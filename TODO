ibis:

+ on closed world: wait in createIbis (or Ibis constructor) until everyone
  is present??? The documentation said that we did, but we didn't...
  No, explicit method to wait for all.
- introduce IbisCapabilities, PortType (both extend CapabilitySet),
  PredefinedCapabilities goes away ...
- split up ibis in multiple seperate subprojects
- move applications to a real tree, use packages.
- update docs
- while(true) {fix eclipse warnings}
- migrate leftover prints to log4j (should we? Performance!)
  (Ceriel: did Ibis implementation).
- steering/monitoring interface
+ to think about: would it be a good idea to allow an active upcall per
  connection instead of per receiveport? This would make satin more simple:
  no longer a receiveport per sender. We thought about it, and decided it
  was not a good idea.

ibis registry:
- gossip Registry

abstract implementation:
- if closed.world is selected, check if ibis.pool.hosts is set, and ignore
  joins beyond total hosts, and all leaves.

implementations:
- fix/improve performance of MpiIbis
+ implement stacking Ibis (Done Ceriel) 
- implement multi Ibis???
- somehow implement lrmc in Ibis (not on top of ...) or in a stacking Ibis.
  Then, this would be the way to do MANY_TO_MANY.

apps:
- check results of the different barnes versions

ibis-util:
- remove dependancy on Smartsockets (move PoolInfo to the rmi/shared stuff?).

website:
- update "ibis" overview picture with new/changed implementations
- add overview section
- update/create each subproject page

satin:
- add semantic analysis to the compiler
- forgotten sync statements
- make return / throw an implicit sync again?
- add comments to abort / inlet machinism
- shutdownhook -> System.exit
- satinc does not understand monitorenter/monitor exit instructions (othello)
- detection of what is an inlet: now, if the invocation is inside a try-catch
  it is assumed to be an inlet. Is this OK? (Maybe change to checked Exception)
- ant test should also run satin apps sequentially
  (It does, does'nt it? (Ceriel) No, it does not run non-rewritten code)
- investigate invocation record cache again. It makes a huge difference for
  performance of small tasks. The fact that it does not seem to work is an
  indication that there is a bug somewhere: someone touches an invocation
  record after it has been cleared!
- update docs: don't call System.exit at the end of main(). Satin should be
  allowed to terminate normally. If main() calls exit, fault-tolerance will
  think that the master died, and restart the master on another node!
  Or: could the Satin rewriter somehow deal with this? Or: shutdown hook?
- Bug: If the user "main" exits before all satin instances are fully
  initialized satin doesn't exit properly.

satin-so:
- count all messages+sizes for the total messages/data sent statistics --Rob
- do not send the same object (and the same version) twice.
  This can happen if it is both broadcast, and pulled at the same time --Rob
- Allow shared objects to be passed anywhere in the parameter data 
  structures. Now only directly as a param. Maybe use stubs instead of
  direct access? This would make the implementation much easier --Rob
- message combining does not help because:  (--Rob)
    - object-id is sent every time (long string)
    - combiner is synchronized
    - overhead of method calls, serialization

Post-ibis-2.0:
- while(true) {fix eclipse warnings}
- change codmon performance measurements to "sane" benchmarks
- more efficient clone? Maybe generate code that clones without using 
  serialization. Could be done for objects passed as a param
  to a spawn, for instance. If code is not there, fall back to current impl.

