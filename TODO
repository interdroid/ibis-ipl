Legend:
- = current
+ = done
* = new since last core meeting

##### Ibis 2.0 ####

ipl:
- check properties for unknown properties
* add "fillTimeout" option to sendport.connect().
* add sequencing support to the ipl

Ibis Factory:
- add support for stacking to the factory (don't add an Ibis to a stack twice)
- add a flag to each Ibis to denote if it should be automatically selected or not.
  The dummy stacking Ibis should never be selected, nor should NioIbis
- fix/remove weird Location.cluster().
* Only select the first matching Ibis, don't try all of them.
* Add a seperate "checker" object for each Ibis implementation to determine
  which Ibis to use.

IbisC:
* remove rewriting of "flat list of class files"
* catch (NullPointeR) exceptions by Bcel, if possible
* add classes in the parameters to the classpath

capabilities:
+ introduce IbisCapabilities, PortType (both extend CapabilitySet),
  PredefinedCapabilities goes away ... (Done Ceriel)
+ make IbisCapabilities, PortType entries simple booleans. (Done Ceriel).
- ibis.util.io capabilities.
- add registry capabilities.

management:
- ibis.ipl.Managable: Map strings to strings instead of strings to object?
  (Niels).
- ibis.ipl.Managable: throw exception on unrecognized property name.
- sendport/receiveport count methods: replace by Managable?
- ibis printStatistics: replace by Managable?

ibis registry:
- forget unneeded event history
* after doing an accept, fork a new thread immediately
* check if all Ibisses in a pool are of the same implementation, version, etc.

implementations:
- Generic: if closed.world is selected, check if ibis.pool.hosts is set, and 
  ignore joins beyond total hosts, and all leaves.
* TcpIbis: fork a thread immediately after doing an "accept". Don't do a
  handshake first.
* Fix deadlocks due to lazily creating serialization streams in TcpIbis.
* catch InvocationTargeExceptions, and thow the cause of this runtime exception
  instead.
* Add an IbisIOException (with a cause)

applications:
- check results of the different barnes versions
- remove old-n-useless applications (if any)
* build jars by default


ibis-util:
+ move PoolInfo to ibis-server (Done, Niels)
+ remove dependancy on Smartsockets.

packaging/distribution:
+ layout package.html in ibis.ipl.
- split up ibis in multiple separate subprojects:
	+ ipl
	+ util
	+ server
	- programming models
	- io?
	- compile?
- move applications to their repective sub-project.
- update docs
- migrate leftover prints to log4j, surround with if (DEBUG){}
  in performance critical section
- print output like javac in ibisc
- while(true) {fix eclipse warnings}
- Api docs of IPL: read, clarify, improve (Niels: Done SendPort).
- clean-up scripts
- fix automatic starting of Ibis-server in "ant test" and "ibis-prun" one way
  or another
* clean up doc building scripts
* fix codmon
* put each ibis in a seperate jar


website:
- update "ibis" overview picture with new/changed implementations
- add overview section
- update/create each subproject page
- add javadoc top-button where applicable

##### Ibis 2.X ####

Ibis:
- while(true) {fix eclipse warnings}
- more efficient clone? Maybe generate code that clones without using 
  serialization. Could be done for objects passed as a param
  to a spawn, for instance. If code is not there, fall back to current impl.

ibis registry:
- gossip Registry

implementations:
- fix/improve performance of MpiIbis
- Implement multi Ibis.
- Implement LRMC Ibis
  
deployment/testing/benchmarking:
- implement "Ibis deployment application" using the GAT
- implement GUI/Scripting/Shell/Commandline interface on Ibis deployment app
- reimplement codmon on-top-of the GAT
- change codmon performance measurements to "sane" benchmarks


satin:
- add semantic analysis to the compiler
- forgotten sync statements
- make return / throw an implicit sync again?
- add comments to abort / inlet machinism
- shutdownhook -> System.exit
- satinc does not understand monitorenter/monitor exit instructions (othello)
- detection of what is an inlet: now, if the invocation is inside a try-catch
  it is assumed to be an inlet. Is this OK? (Maybe change to checked Exception)
- ant test should also run satin apps sequentially
  (It does, does'nt it? (Ceriel) No, it does not run non-rewritten code)
- investigate invocation record cache again. It makes a huge difference for
  performance of small tasks. The fact that it does not seem to work is an
  indication that there is a bug somewhere: someone touches an invocation
  record after it has been cleared!
- update docs: don't call System.exit at the end of main(). Satin should be
  allowed to terminate normally. If main() calls exit, fault-tolerance will
  think that the master died, and restart the master on another node!
  Or: could the Satin rewriter somehow deal with this? Or: shutdown hook?
- Bug: If the user "main" exits before all satin instances are fully
  initialized satin doesn't exit properly.

satin-so:
- count all messages+sizes for the total messages/data sent statistics --Rob
- do not send the same object (and the same version) twice.
  This can happen if it is both broadcast, and pulled at the same time --Rob
- Allow shared objects to be passed anywhere in the parameter data 
  structures. Now only directly as a param. Maybe use stubs instead of
  direct access? This would make the implementation much easier --Rob
- message combining does not help because:  (--Rob)
    - object-id is sent every time (long string)
    - combiner is synchronized
    - overhead of method calls, serialization