\documentclass[10pt]{article}

\usepackage{url}
\usepackage{graphicx}
\usepackage{times}

\begin{document}

\title{Ibis Communication Library Programmer's Manual}

\author{http://www.cs.vu.nl/ibis}

\maketitle

\section{Introduction}

This manual explains how to program applications using the Ibis
communucation library. Ibis is a portable, high performance, Java based
library. For information on how to run applications using this library,
see the Ibis user's manual, available in the Ibis distribution in the
\texttt{doc} directory, or on the Ibis
website\footnote{\url{http://www.cs.vu.nl/ibis}}.

In this manual, we will focus on concepts and methodsm rather than
details like exact parameters of functions. For this type of
information, see the Javadoc for Ibis. This is available in the
\texttt{javadoc} directory of the distribution, and on the website.

This manual is split up into several different sections. First, we will
explain the different parts of the IPL, the interface to the Ibis
communication library. Second, we explain how to compile applications
which use Ibis. Last, we will give some examples of applications which
use Ibis, to show how to use Ibis in practice.

\section{IPL Overview}

%-- ipl picture, implementations, upcalls, identifiers, instances

\begin{figure} \centering
\includegraphics[width=0.9\textwidth]{../images/old-ibis-design.eps}
\caption{Ibis design overview} \label{design}
\end{figure}

This section will give a high level overview of the different parts of
the IPL.  For an overview of the design of Ibis, see
Figure~\ref{design}. The Ibis communication library is build up around
the \emph{Ibis Portability Layer(IPL)}. This layer offers applications a
grid aware communication library, independant of the actual network
used. Ibis can dynamically select a suitable implementation at run-time.
The Ibis communication library ships with several different TCP based
implementation, but implementations based on native platforms such as
MPI and Myrinet are also possible.

Using the IPL, we implemented several different programming models, such
as the divide-and-conquer Satin model, and the Group Based Method
Invocation(GMI) model. A discussion of these models lies outside the
scope of this manual. For more information on the programming models,
see the Ibis website. As an alternative to using a intermediate
programming model, applications can also be written directly on top of
the IPL. The main target audiance of this manual are programmers using
the IPL in an application and programming model writers.

A central concept in the IPL is the \emph{Ibis instance}. In general,
one Ibis instance is created on each machine participating in a
particular distributed application. Each of these instances has a unique
\emph{Ibis Identifier}, used thoughout the library to denote this
instance.

Another often used concept is the \emph{upcall}. Upcalls can be used
instead of downcalls(explicit receipt, polling) in a number of cases.
These cases include receiving messages, getting noticications of new
connections, and updates on new Ibis instances joining a computation.

\subsection{Send and Receive Ports}

%-- send port, receive port, connections, porttypes

\begin{figure} \centering
\includegraphics[width=0.5\textwidth]{../images/ports.eps}
\caption{Ibis send and receive port configurations} \label{ports}
\end{figure}

The IPL is based on uni-directional connection oriented pipes. In the
model, \emph{send ports} are connected to \emph{receive ports}. See
Figure~\ref{ports} for some examples. Connecting a single send port to a
single receive port leads to a simple one-to-one connection. But, it is
also possible to connect a send port to multiple receive ports for a
one-to-many multicast, or multiple send ports to a single receive port
for many-to-one client server type communication. Even connecting
multiple send ports to multiple receive ports is possible, although this
many-to-many communication model is currently not supported by the
standard TCP based implementation of Ibis.

\begin{figure} \centering
\includegraphics[width=0.5\textwidth]{../images/port_types.eps}
\caption{Port types} \label{port_types}
\end{figure}

Ports in Ibis are typed (see Figure~\ref{port_types}). Types are
determined by the communication patterrn (one-to-one, one-to-many,
many-to-one, many-to-many), the type of data that can be send,
reliability, and others. Sendports can only be connected to receive
ports of the same type. This allows for some sanity checks on the
application, and allows Ibis to select the most apropriate
implementation of the communication channel.

\subsection{Messages and Serialization}

%--messages, serialization, bytecode rewriting

Once a connection is established between send and receive ports, data
can now be send. Send and receiveports in Ibis communicate using
messages. A so called \emph{write message} is created at the send port,
and can be filled with all primitive data types of Java such as bytes, integers
and strings, as well as more complex data structures in the form of
Java \texttt{Objects}. Also, arrays of primitive types and object can be
send. When the user is done writing data to a message a \texttt{finish}
message must be called to denote the message has been completed.

Once data is written using a write message at the send port, this
message will arrive at the receive port as a \emph{read message}. There,
the data can be read again using functions equivalent to the ones in
write message. Data must be read from the read message in the same order
as it was written in the write message.

The size of a message is unlimited in Ibis. However, at any point in
time, only a single message can be active at a port. This allows Ibis to
start sending data to the receiver as soon as it is written in the
message. So, while data is still being written to a message at the
sender, it may already be read at the receiver. This streaming behaviour
makes communication in Ibis much more efficient.

Serialization of Objects is the translation of data into bytes suitable for
sending across a network. Ibis is capable of several different versions
of serialization, depending on the needs of the user. These versions
differ in the types of data they support. Some only support sending
bytes, some only primitive types, and some also allow sending objects.

Two different object serialization versions are present in Ibis.  One is
the standard Java object serialization, the other a high performance
implementation of object serialization. For this high performance
\emph{Ibis Serialization} implementation to work, an extra step is needed
when compiling the application. Some extra code is generated to
facilitate sending objects efficiently. See Section\ref{compiling} for
more info.

\subsection{Pools and the Registry}

%-- pools, registry, join, leave, died, election, location

Each Ibis instance is a member of a \emph{Pool}. The Ibis
\emph{Registry} keeps track of all the members of the pool, and notifies
all Ibises whenever a new Ibis instance joins this pool, leaves the
pool, or even when a Ibis dies unexpectedly.

Applications can use the registry mechanism to get notified of any
changes to the pool. Also, it is possible to do a \emph{election}, which
can be used to select Ibis instances which are special such as servers.
Each election has a unique name in the form of a String, and will elect
a winner from the candidates for this election. Elections are not
democratic though, and usually the first candidate is elected as the
winner. It is also possible to request the outcome of an election
without being a candidate. 

\subsection{Capabilities}

To facilitate the selection of the best implementation for all the
functionality required of Ibis from a user, Ibis uses a
\emph{capability} based selection mechanism. For each Ibis instance, and
each port type, the user can specify which capabilities are needed. Each
capability enables a certain part of the API. For instance, sending
objects in message is only possible if the "object serialization"
capability is enabled in the port type. Likewise, elections can only be
done if either the "unreliable election" or the "strict election"
capability is enabled. The difference between the two being the
consistency model of the elections. 

We list the most important capabilities below. The complete list of
predefined capabilities can be found in the (Javadoc of the)
\texttt{PredefinedCapabilities} class.

Capabilities of an Ibis instance:

\begin{description}

\item[CLOSED_WORLD]
The Ibises in the pool are determined at the start of the
run. After these Ibises have joined, any further requests to join the
pool will be denied.

\item[ELECTIONS_STRICT]
Indicates elections are supported, and they adhere to the following 
consistency model: Each election has a single, unique winner at any
given point in time, and


\end{description}

Capabilities of a Port type:

\begin{description}
\item[CONNECTION\_ONE\_TO\_ONE]
One-to-one (unicast) communication is supported (if an Ibis
implementation
does not support this, you may wonder what it \emph{does} support).

\item[CONNECTION\_ONE\_TO\_MANY]
one-to-many (multicast) communication is supported
(in Ibis terms: a sendport
may connect to multiple receiveports).

\item[CONNECTION\_MANY\_TO\_ONE]
many-to-one communication is supported (in Ibis terms: multiple
sendports may connect to a single receiveport).

\item[COMMUNICATION\_FIFO]
messages from a send port are delivered to the receive ports it is
connected to in the order in which they were sent.

\item[CONNECTION\_DOWNCALLS]
connection downcalls are supported. This means that the user can
invoke methods to see which connections were lost or created.

\item[CONNECTION\_DOWNCALLS]
connection upcalls are supported. This means that an upcall
handler can be installed that is invoked whenever a new connection
arrives
or a connection is lost.

\item[COMMUNICATION\_NUMBERED]
all messages originating from any send port of a specific port type have
a sequence number. This allows the application to do its own sequencing.

\item[COMMUNICATION\_RELIABLE]
reliable communication is supported, that is,
a reliable communication protocol is used.
When not specified, an Ibis implementation may be chosen that does not
explicitly
support reliable communication.

\item[RECEIVE\_AUTO\_UPCALLS]
upcalls are supported and polling for them is not required.
This means that when the user creates a receiveport with an upcall
handler installed, when a message arrives at that receive port, 
this upcall handler is invoked automatically.

\item[RECEIVE\_POLL\_UPCALLS]
upcalls are supported but polling for them may be needed. When an
Ibis implementation claims that it supports this, it may also do

RECEIVE\_AUTO\_UPCALLS, but polling does no harm. When an application
asks for
this (and not RECEIVE\_AUTO\_UPCALLS), it must poll.

\item[RECEIVE\_EXPLICIT]
explicit receive is supported.
This is the alternative to upcalls for receiving messages.

\item[SERIALIZATION\_BYTE]
Only the methods \texttt{readByte()}, \texttt{writeByte()},
\texttt{readArray(byte[])} and \texttt{writeArray(byte[])} are
supported.

\item[SERIALIZATION\_DATA]
Only \texttt{read()}/\texttt{write()} and
\texttt{readArray()}/\texttt{writeArray()} of primitive types are
supported.

\item[SERIALIZATION\_OBJECT]
Some sort of object serialization is supported.
This requires user-defined
\texttt{writeObject()}/\texttt{readObject()} methods to be symmetrical,
that is,
each write in \texttt{writeObject()} must have a corresponding read
in \texttt{readObject()} (and vice versa).

\item[SERIALIZATION\_STRICTOBJECT]
Sun serialization (through
\texttt{java.io.ObjectOutputStream/InputStream}) is
supported. In some regards, this object serialization implementation is
more
forgiving than SERIALIZATION\_OBJECT.

\item[WORLDMODEL\_OPEN]
Ibises can join and leave the run at any time during the run.

\end{description}

\subsection{Properties}

Properties are used in Ibis for setting configuration options at
run-time. These include where to find the ibis Implementations and the name
of the pool to join. Properties can be passed to a Ibis when it is
created, but Ibis can also add properties specified on the command line
by default. See the user's guide for more information on the various
properties of ibis and their usage.

\section{Compiling applications}\

%-- add ipl.jar to classpath, rewrite using ibisc, example ant build file.

\section{Tutorial}

\subsection{Hello}

\subsection{Upcalls}

\subsection{Registry}

\subsection{One-to-Many}

\subsection{Many-to-One}

\subsection{Client-Server}

\subsection{Client-Server with Objects}

\section{Further Reading}

The Javadoc included in the \texttt{javadoc} directory has detailed
information on all classes and their functions.

The Ibis web page \url{http://www.cs.vu.nl/ibis} lists all
the documentation and software available for Ibis, including papers, and
slides of presentations.

For detailed information on running an Ibis application see the
User's Manual, available in the docs directory of the Ibis
distribution.

\end{document}
