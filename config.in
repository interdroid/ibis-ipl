# -------------- start of user configuration -----------------------------

# When using javac or jikes, set these values correctly and use "make"
# or "make java". (Also make sure that your CLASSPATH is set correctly).     

# The Ibis Makefiles assume definitions of the following variables:
# SRC		= List of .java files that must be compiled
# INNER_CLASS	= List of Bla.class files whose source file is not Bla.java
#		  but some other .java file
#
# MAIN		= Name of .java file that contains main class for application
# OUT		= Name of executable
#
# NATIVE_SRC	= List of .java files that have native methods
# C_SRC		= List of .c files that contain native code
# PACKAGE	= package in . notation
# SO_LIB	= libbla.so for jit builds. Otherwise, the default
#		  Ibis library (IBISROOT/ibis/lib/libibis.a) is used.
#
# SERIALIZABLE	= List of .java files that implement Serializable
# REMOTE        = List of .java files that implement remote
#
# All these must be specified *before* inclusion of config.mk!

.PHONY:		manta
.PHONY:		java

# default:	manta
default:	java

PROFILE		= 0
OPTIMIZE	= 1

MYRINET_ROOT    = /usr/local/package/myrinet/lib/intel_linux

# -------------- end of build time configuration ----------------------------

PANDA		= @PANDA_ROOT@
PANDA_NETWORK	= @PANDA_NETWORK@
DAS		= @DAS_LIB@
JPATH           = @JAVA_ROOT@
export JPATH
JAVAC           = @JAVAC@
BCEL		= @BCEL_ROOT@
ifndef IBIS_ROOT
IBIS_ROOT	= @IBIS_ROOT@
endif
LFC_ROOT	= @LFC_ROOT@
GM_ROOT		= @GM_ROOT@


# -------------- end of configure time configuration ------------------------

JAVAC_COMMAND   = $(JAVAC) $(JAVACFLAGS) $(JAVAOPTFLAGS)
JAVAH_COMMAND   = $(JPATH)/bin/javah $(JAVAHFLAGS)
JRE		= $(JPATH)/jre/lib
ifeq (IBMJava2-14, $(findstring IBMJava2-14,$(JPATH)))
JAVART		= $(JRE)/core.jar:$(JRE)/server.jar
else
JAVART		= $(JRE)/rt.jar
endif
JAVACLASSPATH	= .:$(IBIS_ROOT)/ibis/classlibs:$(IBIS_ROOT):$(IBIS_ROOT)/ibis:.:$(JAVART):$(IBIS_ROOT)/ibis/bcel-additions:$(BCEL)/bcel.jar:$(BCEL)/lib
JAVABOOTCLASSPATH = $(IBIS_ROOT)/ibis/classlibs:$(IBIS_ROOT)/ibis
JAVABOOTLIBPATH = -Dsun.boot.library.path=$(IBIS_ROOT)/ibis/lib:$(JPATH)/jre/bin:$(JPATH)/jre/lib/i386
JAVACFLAGS	+= -g -classpath $(JAVACLASSPATH)
JAVAHFLAGS      += -classpath $(JAVACLASSPATH)
CLASSPATH	= $(JAVACLASSPATH)
export CLASSPATH

LD_LIBRARY_PATH	= $(IBIS_ROOT)/ibis/lib
export LD_LIBRARY_PATH

LD_ASSUME_KERNEL	= 2.2.5
export LD_ASSUME_KERNEL

# PANDA_THREADS	= ot
PANDA_THREADS	= pthreads

IBERTY	        = $(MYRINET_ROOT)/libiberty.a
BFD		= $(MYRINET_ROOT)/libbfd.a
LANAIDEVICE	= $(MYRINET_ROOT)/libLanaiDevice.a
DPI		= $(MYRINET_ROOT)/libDpi.a
ENS		= /usr/proj/FastSockets/enameserver/enameserver-0.13/libens.a
ifeq (1, $(OPTIMIZE))
LFC	        = $(LFC_ROOT)/lib/optimized/liblfc.a
PANDA_LIB	= $(PANDA)/panda4.0/lib/i386_linux/$(PANDA_NETWORK)/no_threads/optimized/libpanda.a
else
LFC	        = $(LFC_ROOT)/lib/debug/liblfc.a
PANDA_LIB	= $(PANDA)/panda4.0/lib/i386_linux/$(PANDA_NETWORK)/no_threads/libpanda.a
endif
GM		= $(GM_ROOT)/lib/libgm.a
DASLIB		= /usr/local/VU/daslib

GROUPC_COMMAND	= $(JPATH)/bin/java -classpath $(JAVACLASSPATH) ibis.frontend.group.Main

GROUP_FILES	= $(SRC:%.java=%.gjava)
CLASS_FILES	= $(SRC:%.java=%.class) $(INNER_CLASS)
MAIN_CLASS	= $(MAIN:%.java=%.class)
MAIN_CLASS_NAME	= $(MAIN:%.java=%)

LDSO	= gcc -shared

SATINC_COMMAND = $(JPATH)/bin/java -classpath $(JAVACLASSPATH) ibis.frontend.satin.Satinc -keep -compiler "$(JAVAC) -g -classpath $(JAVACLASSPATH)"

IOC_COMMAND = $(JPATH)/bin/java -classpath $(JAVACLASSPATH) ibis.frontend.io.IOGenerator

IBISC_COMMAND = $(JPATH)/bin/java -classpath $(JAVACLASSPATH) ibis.frontend.ibis.Ibisc -compiler  "$(JAVAC) -g -classpath $(JAVACLASSPATH)" -mantac "$(MANTAC_COMMAND)"


# When using Manta, set these values correctly and use "make manta"

ifeq (, $(PANDA_NETWORK))
PANDA_NETWORK	= udp
endif

CC		= gcc

MANTACFLAGS	=
CFLAGS		=

ifeq (1, $(OPTIMIZE))
JAVAOPTFLAGS	+= -O
CFLAGS		+= -O3 -DNDEBUG
else
MANTACFLAGS	+= -no-opt-comm
MANTACFLAGS	+= -no-inline -g
endif
ifeq (1, $(PROFILE))
CFLAGS		+= -pg
# CFLAGS		+= -fno-inline-functions
MANTACFLAGS	+= -pg
endif

ifeq (1, $(BUILD_MANTA))
CFLAGS	+= -I$(MANTA)
CFLAGS	+= -I$(MANTA)/include/shared/jni
else
CFLAGS	+= -I$(JPATH)/include -I$(JPATH)/include/linux
endif
CFLAGS	+= -g -Wall -Wmissing-prototypes -Wstrict-prototypes -MD

ifeq (,$(PACKAGE))
PACKAGEDOT	:= ""
else
PACKAGEDOT	:= $(PACKAGE).
PACKAGE_SLASH	:= $(subst .,/,$(PACKAGE))
PACKAGE_MANGLE	:= $(subst .,_,$(PACKAGE))
endif

LASM_CACHE	:= $(IBIS_ROOT)/ibis/LASM_IBIS_CACHE

MANTA	= @MANTA_ROOT@
export MANTA
MANTACLASSPATH	= .:$(IBIS_ROOT):$(IBIS_ROOT)/ibis:$(MANTA)/javalibs

MANTACFLAGS	+= -classpath $(MANTACLASSPATH)
MANTACFLAGS	+= -g
MANTACFLAGS	+= -no-shared-link
MANTACFLAGS	+= -panda $(PANDA)/panda4.0
ifeq (, $(OUT))	# Is this what we want???? No apps stuff exported... RFHH
MANTACFLAGS	+= -output_cc $(LASM_CACHE)
endif
MANTACFLAGS	+= -user_cc $(LASM_CACHE)
ifeq (lfc, $(PANDA_NETWORK))
MANTACFLAGS	+= -myrinet
endif
MANTAC_COMMAND = $(MANTA)/mantac $(MANTACFLAGS)

SRC		+= $(REMOTE)
SRC		+= $(REMOTE_STUBS)
SRC		+= $(REMOTE_SKELETONS)

ifneq (, $(strip $(SERIALIZABLE)))
SERIALIZABLE_O	:= $(SERIALIZABLE:%.java=%.o)
SERIALIZABLE_CLASS	:= $(SERIALIZABLE:%.java=%.class)
.PRECIOUS:	$(SERIALIZABLE_CLASS)
# O_FILES		:= $(filter-out $(SERIALIZABLE_O), $(O_FILES))
O_FILES		+= $(SERIALIZABLE_O:%.o=%_ibis_io_Generator.o)

SERIALIZABLE_GENERATED	:= $(SERIALIZABLE:%.java=%_ibis_io_Generator.class)
CLASS_FILES	+= $(SERIALIZABLE_GENERATED)
endif

# It turns out that stub files are also Serializable
CLASS_FILES	+= $(REMOTE:%.java=rmi_stub_%_ibis_io_Generator.class)

O_FILES		:= $(CLASS_FILES:%.class=%.o)

ifeq (ibis., $(findstring ibis.,$(PACKAGE)))
PKG_SUF		:= .$(PACKAGE_MANGLE)
else
PKG_SUF		:= .o
endif
PKG_O_FILES	:= $(O_FILES:%.o=%$(PKG_SUF))
PKG_O_DOLLAR	:= $(subst $$,\$$,$(PKG_O_FILES))

MANTA_LIB	= $(IBIS_ROOT)/ibis/lib/libibis.a
MANTA_SO	= $(MANTA_LIB:%.a=%.so)
MANTA_LDLIBS	=
MANTA_LDLIBS	+= $(MANTA_LIB)

ifeq (gm, $(MPI_MODE))
    MPI		= /usr/local/mpich/mpich-gm
else
    ifeq (panda, $(MPI_MODE))
	MPI		= /home/rutger/mpich/mpich-panda/mpich/mpich
    else
	ifeq (p4, $(MPI_MODE))
	    MPI		= /usr/local/mpich/1.2.4/ch_p4
	    # MPI		= /home/rutger/mpich/mpich-1.2.4..8a
	endif
    endif
endif

ifeq (mpi, $(MP_MODE))
    MANTA_LDLIBS	+= $(IBIS_ROOT)/ibis/lib/libibis_mp_mpi.a
    ifeq (gm, $(MPI_MODE))
	MANTA_LDLIBS	+= -L$(MPI)/lib -lmpich
	MANTA_LDLIBS	+= $(GM)
	MANTA_LDLIBS	+= -lpthread
	MANTACFLAGS	:= $(filter-out -myrinet, $(MANTACFLAGS))
    else
	ifeq (panda, $(MPI_MODE))
	    ifeq (1, $(OPTIMIZE))
		MANTA_LDLIBS	+= $(MPI)/lib/i386/ch_panda4/optimized/libmpi.a
	    else
		MANTA_LDLIBS	+= $(MPI)/lib/i386/ch_panda4/libmpi.a
	    endif
	else
	    ifeq (p4, $(MPI_MODE))
		MANTA_LDLIBS	+= -L$(MPI)/lib -lmpich
		MANTA_LDLIBS	+= -lpthread
		MANTACFLAGS	:= $(filter-out -myrinet, $(MANTACFLAGS))
	    else
		@@@#$$$$$$$$$$$$$$
	    endif
	endif
    endif
else
    MANTA_LDLIBS	+= $(IBIS_ROOT)/ibis/lib/libibis_mp_panda.a
endif

#JACKAL_PATCHERS	=
#JACKAL_PATCHERS	+= $(SRC:%.java=diff_patch_%.c)
#JACKAL_PATCHERS	+= $(MAIN:%.java=diff_patch_%.c)
#JACKAL_PATCHERS	+= $(SERIALIZE:%=diff_patch_%.c)

TRASH_FILES  =  
TRASH_FILES += *core 
TRASH_FILES += *.o
TRASH_FILES += stub_*.h
TRASH_FILES += packagers_*.c
TRASH_FILES += packagers_*.h
TRASH_FILES += *.jac
TRASH_FILES += *~
TRASH_FILES += *.s
TRASH_FILES += *.class
TRASH_FILES += *.lasm
TRASH_FILES += *.d
TRASH_FILES += Satin_*_InvocationRecord.java
TRASH_FILES += Satin_*_ReturnRecord.java
TRASH_FILES += -r LASM_CACHE
TRASH_FILES += Satin_*
TRASH_FILES += *.jad
TRASH_FILES += $(PKG_O_FILES) $(PKG_O_DOLLAR)
TRASH_FILES	+= $(REMOTE_STUBS)
TRASH_FILES	+= $(REMOTE_SKELETONS)

#conversion rules

.SUFFIXES:
.SUFFIXES:      .o .class .java .c $(PKG_SUF) _ibis_io_Generator.class


# Rules and targets for java (and Manta) compilation
#

.java.class:
	$(JAVAC_COMMAND) $*.java


.class_ibis_io_Generator.class:
	$(IOC_COMMAND) $(PACKAGEDOT)$*

rmi_stub_%.java:	%.class
	-rm -f $@
	$(JPATH)/bin/java -classpath $(CLASSPATH) ibis.frontend.rmi.Main -v $*

rmi_skeleton_%.java:	%.class
	-rm -f $@
	$(JPATH)/bin/java -classpath $(CLASSPATH) ibis.frontend.rmi.Main -v $*


ifneq (, $(strip $(SERIALIZABLE)))
.PHONY: serializers
REMOTE_STUBS		= $(REMOTE:%.java=rmi_stub_%.java)
REMOTE_SKELETONS	= $(REMOTE:%.java=rmi_skeleton_%.java)
.PRECIOUS:	$(REMOTE_STUBS) $(REMOTE_SKELETONS)
serializers:	$(SERIALIZABLE_GENERATED)
serializers:	$(REMOTE_STUBS)
serializers:	$(REMOTE_SKELETONS)
endif


java:	class_files

.PHONY:	class_files
class_files:
ifneq (, $(strip $(SERIALIZABLE)))
	$(MAKE) $(MFLAGS) serializers
endif
ifneq (, $(strip $(CLASS_FILES) $(MAIN_CLASS)))
	$(MAKE) $(MFLAGS) $(CLASS_FILES) $(MAIN_CLASS)
endif



# Rules and targets for Manta compilation
#

.class.o:
	$(MANTAC_COMMAND) -c $(subst $$,\$$,$*.class)

.o$(PKG_SUF):
	cp $(subst $$,\$$,$*.o) $(subst $$,\$$,$@)


manta:	$(LASM_CACHE)

manta:	manta_local

# Compile the files in the current directory; first make class files and
# serializers, then invoke mantac
#
.PHONY:	manta_local
manta_local:
	@echo Make class files and serializers
	$(MAKE) $(MFLAGS) BUILD_MANTA=1 class_files
ifneq (, $(strip $(C_SRC)))
	@echo Now make manta:.h files for native
	$(MAKE) $(MFLAGS) BUILD_MANTA=1 h_files
endif
ifeq (,$(PACKAGE))
ifneq (, $(OUT))
	@echo Now make manta:out $(OUT)
	$(MAKE) $(MFLAGS) BUILD_MANTA=1 $(OUT)
endif
else
	@echo Now make manta:manta_lib
	$(MAKE) $(MFLAGS) BUILD_MANTA=1 manta_lib
endif


# Invoke mantac on the class files
#
.PHONY:	manta_lib
manta_lib:	$(PKG_O_FILES) $(C_OBJ) $(SO_LIB)
ifneq (, $(C_SRC))
	# DON'T understand. Why is $(C_OBJ) as a target insufficient????
	$(MAKE) $(MFLAGS) $(C_OBJ)
endif
	$(AR) ru $(MANTA_LIB) $(PKG_O_DOLLAR) $(C_OBJ)

# Shared support for native code
#
H_FILES		= $(NATIVE_SRC:%.java=$(PACKAGE_MANGLE)_%.h)

h_files:	$(H_FILES)

$(PACKAGE_MANGLE)_%.h:	%.java
	$(JAVAH_COMMAND) -jni $(PACKAGE).$(basename $*)
	touch $@

C_OBJ		= $(C_SRC:%.c=%.o)

$(SO_LIB):	h_files $(C_LIB) $(C_OBJ)
	$(LDSO) -o $@ $(C_OBJ)
	cp $(SO_LIB) $(IBIS_ROOT)/ibis/lib


$(LASM_CACHE):
	-mkdir -p $@


# A link-only target is a much-used feature in making/debugging applications
#
link:
	$(MANTAC_COMMAND) -link-only \
		-o $(OUT) \
		$(MAIN:%.java=%.o) \
		$(O_FILES) \
		$(MANTA_LDLIBS)

$(OUT): $(MAIN_CLASS) $(O_FILES) $(MANTA_LIB)
	echo O_FILES = $(O_FILES)
	$(MANTAC_COMMAND) -o $@ $(MAIN_CLASS) $(O_FILES) $(MANTA_LDLIBS)


.PHONY:	run
run:
	$(JPATH)/bin/java $(JAVACFLAGS) $(MAIN:%.java=%)

# Print a feasible prun command; mouse this into your command line
#
.PHONY:	prun
prun:
	@echo "prun IBP_SEND_SYNC=100 MANTA_NO_PANDA=1 PAN_COMM_NO_INTR=1 PAN_COMM_NO_IDLE_POLL=1 LD_LIBRARY_PATH=$(LD_LIBRARY_PATH):. CLASSPATH=$(CLASSPATH) -no-panda -Dname_server=mercury.cs.vu.nl -Dname_server_pool=rutger $(JPATH)/bin/java 'hosts' $(JAVACFLAGS) $(MAIN:%.java=%) 'args ...'"
